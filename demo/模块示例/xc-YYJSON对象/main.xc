//示例需解析json格式化结构,中文同时支持GBK编码和UTF8编码,输入是什么编码输出同样是什么编码,你别解析个UTF8文件,用GBK获取属性..那肯定是啥也没有 自行转换函数: 炫彩_文本A到UTF8 炫彩_UTF8到文本A
//{
//    "str": "string",
//    "int": 8848,
//    "double": 3.1415926,
//    "bool": true,
//    "array": [
//        123456,
//        0.123456,
//        null,
//        {
//            "substr": "substring",
//            "subint": 10086,
//            "double": 7.23521125
//        }
//    ]
//}

//	A表示使用定义 文本型A	R"()"  表示括号中间的字符串为RAW结构,可以不使用转义符按原样定义文本
文本型A json文本 = AR"({"str": "string","int": 8848,"double": 3.1415926,"bool": true,"array": [123456,0.123456,null,{"substr": "substring","subint": 10086,"double": 7.23521125}]})"

函数 整型 YYJSON解析示例()
	//注意,重复说明,中文同时支持GBK编码和UTF8编码,但没有转换,输入是什么编码输出同样是什么编码,你别解析个UTF8文件,用GBK获取属性..那肯定是啥也没有

	//JSON解析 这个类只可获取json解析的键或值,不支持写入输出,yyjson这么设定的
	//JSON对象 这个类可以解析,也可以写入输出,但解析本质上用的是 "JSON解析" 类同样的函数,并且为了能支持写入,把整个解析数据全部复制转换了一次
	//在不需要修改原JSON,只是作为接受数据取值,建议只使用 "JSON解析" 这个类
	
	调试输出("YYJSON解析 示例开始")

	//JSON解析 方式一 申明的时候直接解析
	JSON解析 json(json文本)

	//JSON解析 方式二 先申明的再解析
	JSON解析 json2
	逻辑型 解析结果 = json2.解析(json文本)
	调试输出("JSON解析结果: ", 解析结果)
	//两种解析方式区别只在于是否需要判断解析是否成功..

	//JSON对象 就一种方式
	JSON对象 js
	解析结果 = js.解析(json文本)
	调试输出("JS解析结果: ", 解析结果)

	//读取方式一 使用类方法取限定值 JSON解析 和 JSON对象 都支持这种方式
	文本型A JSON文本值1 = json.取对象(A"str").取文本值() 			//先取对象,再获取限定文本值,如果属性不是文本对象,则为空文本,这个是正确示例
	文本型A JSON文本值2 = json.取对象(A"int").取文本值() 			//先取对象,再获取限定文本值,如果属性不是文本对象,则为空文本,这个是错误示例
	整型 JSON整数值1 = json.取对象(A"int").取整数值() 				//先取对象,再获取限定整型值,如果属性不是整型对象,则为0,这个是正确示例
	整型 JSON整数值2 = json.取对象(A"double").取整数值() 			//先取对象,再获取限定整型值,如果属性不是整型对象,则为0,这个是错误示例
	调试输出("读取方式一 正确示例 取对象 str 文本属性: ", JSON文本值1)  //其他限定类型取值就不做示例了,所有数值类型不存在则为0,逻辑型不存在则为flase
	调试输出("读取方式一 错误示例 取对象 int 文本属性: ", JSON文本值2)
	调试输出("读取方式一 正确示例 取对象 int 整数属性: ", JSON整数值1)
	调试输出("读取方式一 错误示例 取对象 double 整数属性: ", JSON整数值2)

	//读取方式二 使用下标重载取限定值 JSON解析 和 JSON对象 都支持这种方式
	JSON文本值1 = json[A"str"].取文本值() 							//先取对象,再获取限定文本值,如果属性不是文本对象,则为空文本,这个是正确示例
	JSON文本值2 = json[A"int"].取文本值() 							//先取对象,再获取限定文本值,如果属性不是文本对象,则为空文本,这个是错误示例
	JSON整数值1 = json[A"int"].取整数值() 							//先取对象,再获取限定整型值,如果属性不是整型对象,则为0,这个是正确示例
	JSON整数值2 = json[A"double"].取整数值() 						//先取对象,再获取限定整型值,如果属性不是整型对象,则为0,这个是错误示例
	调试输出("读取方式二 正确示例 取对象 str 文本属性: ", JSON文本值1)  //其他限定类型取值就不做示例了,所有数值类型不存在则为0,逻辑型不存在则为flase
	调试输出("读取方式二 错误示例 取对象 int 文本属性: ", JSON文本值2)
	调试输出("读取方式二 正确示例 取对象 int 整数属性: ", JSON整数值1)
	调试输出("读取方式二 错误示例 取对象 double 整数属性: ", JSON整数值2)
	
	//读取方式三 使用下标重载取通用文本值, 注意 JSON对象 不支持这种方式,但是多一个 取通用文本()
	文本型A JSON值1 = json[A"str"]
	文本型A JSON值2 = json[A"int"]
	文本型A JSON值3 = json[A"double"]
	文本型A JSON值4 = json[A"bool"]
	文本型A JSON值5 = json[A"array"]									// array 是一个 JSONArrat 对象 这么操作返回空文本,是错误的方式
	整型 JSON长度 = json[A"array"].长度()						     // 获取array 的成员数
	文本型A JSON值6 = json[A"array"][0]								// array 的第一个成员  序号 0开始哟,等同  json.取对象(A"array").取成员(0)
																				
	//下面3个使用 JSON对象 这个不支持自动重载为文本,本质是同一种实现,但是需要自己调用方法
	文本型A JSON值7 = js[A"array"][1].取通用文本()					// array 的第二个成员
	文本型A JSON值8 = js[A"array"][2].取通用文本()					// array 的第三个成员
	文本型A JSON值9 = js[A"array"][3].取通用文本()					// array 的第四个成员 是一个 JSONObject 这么操作返回空文本,是错误的方式
	调试输出("读取方式三 正确示例 取对象 str 值: ", JSON值1)
	调试输出("读取方式三 正确示例 取对象 int 值: ", JSON值2)
	调试输出("读取方式三 正确示例 取对象 double 值: ", JSON值3)
	调试输出("读取方式三 正确示例 取对象 bool 值: ", JSON值4)
	调试输出("读取方式三 错误示例 取对象 array 值: ", JSON值5)
	调试输出("读取方式三 正确示例 取对象 array 成员数量: ", JSON长度)
	调试输出("读取方式三 正确示例 取对象 array 第1个成员值: ", JSON值6)		
	调试输出("读取方式三 正确示例 取对象 array 第2个成员值: ", JSON值7)		
	调试输出("读取方式三 正确示例 取对象 array 第3个成员值: ", JSON值8)		
	调试输出("读取方式三 错误示例 取对象 array 第4个成员值: ", JSON值9)	
	
	//两个类在取值使用方式中,使用方式不同,但等价
	//其他所有方式相同
	文本型A 嵌套测试1 = json[A"array"][3][A"subint"]
	文本型A 嵌套测试2 = js[A"array"][3][A"subint"].取通用文本()
	调试输出("示例多层嵌套取对象 array 第4个成员 subint 属性值: ", 嵌套测试1, 嵌套测试2) 	

	//示例获取对象对象类型
	//所有类型名称: 		"raw","null","string","array","object","true","false","uint","sint","real","unknown"
	//具体就不解释了...YYJSON原生定义,基本上就是字面理解

	调试输出("json 类型名称是:", json.类型())
	调试输出("json[str] 类型名称是:", json[A"str"].类型())
	调试输出("json[int] 类型名称是:", json[A"int"].类型())
	调试输出("json[double] 类型名称是:", json[A"double"].类型())

	//示例取属性名 注意,本类中没有成员属性,只有成员方法 需加() 获取需要的信息
	//当当前对象是 JSON Object 时 长度取出出的是 键对值 数量
	//序号从0开始,第一个属性名(键名),取属性名 = 取键名,2个名字同一个功能
	调试输出("根 json 类型名称是:", json.类型())
	调试输出("根 json  键对值 数量是:", json.长度())
	调试输出("根 json 第一个属性名称是:", json.取键名(0))
	调试输出("根 json 第二个属性名称是:", json.取键名(1))
	调试输出("根 json 第三个属性名称是:", json.取键名(2))
	调试输出("根 json 第四个属性名称是:", json.取键名(3))
	调试输出("根 json 第五个属性名称是:", json.取键名(4))

	调试输出("json array 第四个成员(index = 3) 类型名称是:", json[A"array"][3].类型())
	调试输出("json array 第四个成员(index = 3) 键对值 数量是:", json[A"array"][3].长度())
	调试输出("json array 第四个成员 第一个属性名称是:", json[A"array"][3].取键名(0))
	调试输出("json array 第四个成员 第二个属性名称是:", json[A"array"][3].取键名(1))
	调试输出("json array 第四个成员 第三个属性名称是:", json[A"array"][3].取键名(2))
	调试输出("json array 第四个成员 第四个属性名称是:", json[A"array"][3].取键名(4), "错误操作,长度只有3,取第四个返回空文本")
	返回 0

函数 整型 YYJSON输出示例()

	//注意,重复说明,中文同时支持GBK编码和UTF8编码,但没有转换,输入是什么编码输出同样是什么编码,你别解析个UTF8文件,用GBK获取属性..那肯定是啥也没有

	//这个示例中, 取对象() 全用下标操作替代,就不演示了...
	调试输出("YYJSON输出 示例开始")

	//空类,默认是 [object]  直接输出是 {}
	JSON对象 json
	文本型A 输出文本 = json.到JSON文本()
	调试输出("一个空的JSON对象: ", 输出文本)

	//空类直接添加成员自动转换成数组,非空..失败
	json.添加成员_文本型(A"我可以自动转换成数组的")
	输出文本 = json.到JSON文本()
	调试输出("一个JSON数组: ", 输出文本)

	//转成 [array] 直接输出是 []
	//将当前原本数据全部移除,强制转为 []
	//正常情况不需要使用这个方法,适用强迫症患者,就是想在一个属性下面显示一个空的数组 []  欸,就是玩...
	json.置空数组()
	输出文本 = json.到JSON文本()
	调试输出("一个空的JSON数组: ", 输出文本)

	//空数组,添加键值对...不支持自动转换..你问我为什么..我偷懒了..
	json[A"哦嚯"] = A"我就试试"
	输出文本 = json.到JSON文本()
	调试输出("一个错误示例,数组里面不能插入键值对: ", 输出文本)

	//建立一个新的数组,添加一些莫名奇妙的成员
	JSON对象 json数组
	json数组.添加成员_文本型(A"我是一个文本")
	json数组.添加成员_RAW(A"这也是一个文本")
	json数组.添加成员_整型(10086)
	json数组.添加成员_小数(3.1415926)
	json数组.添加成员_无符号长整数(10223372036854775807)
	json数组.添加成员_长整数(222222222222222)
	json数组.添加成员_逻辑值(真)
	json数组.添加成员_NULL值()
	调试输出("一个新的各种数据的JSON数组: ", json数组.到JSON文本())

	//强制转换,会清空原数据,会清空原数据,会清空原数据
	json.置对象()
	调试输出("变回一个空的JSON对象: ", json.到JSON文本())

	//但是这个命令主要的作用是 添加新对象属性
	json[A"这是属性名"].置对象(json数组)
	调试输出("数据满满的JSON对象: ", json.到JSON文本())

	json[A"这是属性名"].置对象()
	调试输出("就剩一个括号了: ", json.到JSON文本())

	//其实吧...那几个字也没什么必要输入...
	json[A"这是属性名"] = json数组
	调试输出("数据满满的JSON对象: ", json.到JSON文本())

	//数组里面加入对象
	json数组.添加成员_对象(json)
	调试输出("数组里面加入对象: ", json数组.到JSON文本())

	整型 数组长度 = json数组.长度()
	调试输出("数组长度", 数组长度)
	
	json数组[7].移除() //删除第八个成员..编号 0 开始的哟
	调试输出("删除一个成员后: ", json数组.到JSON文本())
	json数组[8].移除() //这个是错误的..已经移除了一个,没有第九个成员
	调试输出("还是一样的数组: ", json数组.到JSON文本())
	json数组[6].删除() //这两个命令是同一个功能,毛区别没有
	调试输出("用删除试试效果: ", json数组.到JSON文本())

	//下标修改成员数据, 用 = 符号直接赋值 只支持 对象,文本,整数,小数,其他的请用常规方法调用
	json数组[6][A"这是属性名"][0] = A"你是一个文本"
	调试输出("改一个名字看看: ", json数组.到JSON文本())

	json数组[6][A"这是属性名"][1] = 真  //逻辑值会被识别成整数 1 和 0...所以别这么干
	调试输出("这是一个错误示例: ", json数组.到JSON文本())

	json数组[6][A"这是属性名"][1].置逻辑值(假) 
	调试输出("这是一个正确示例: ", json数组.到JSON文本())
	
	//解析一个JSON文本数组,注意,同样会移除原来的数据
	json.解析(A"[1,2,3,4,5,6,7,8,9]")
	json[4] = 5555
	json[5] =A"呆瓜"
	调试输出("解析再修改的json数组: ", json.到JSON文本())

	//替换一下
	json数组[6] = json
	调试输出("替换一下: ", json数组.到JSON文本())

	//基本就到这里了..看完应该会用了吧...了吧...了吧?

	返回 0

函数 整型 入口函数()
	//测试的时候一个一个来,先看解析,看完了把解析执行示例函数注释了,再开输出示例
	//YYJSON解析示例()

	YYJSON输出示例()
	返回 0

