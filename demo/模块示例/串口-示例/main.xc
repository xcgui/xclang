
我的主窗口类  我的主窗口	//主窗口全局变量
串口通信类 m_串口通讯	//串口通讯全局变量
串口接收事件类 m_串口通讯接收事件	//声明串口接收事件全局变量  用于无窗口时的事件挂接
元素句柄 元素句柄_	//编辑框全局句柄


类 我的主窗口类 继承 窗口类,串口数据返回类        //继承串口的数据返回类 实现在窗口类下面回调接收事件
	[绑定信息] //IDE生成的UI绑定信息(UI变量,事件), 支持手动修改, 可收缩隐藏

		[按钮类, _按钮_打开, "按钮_打开"]
			[XE_BNCLICK, 事件_点击_按钮_打开, 0]
		[编辑框类, _编辑框_接收, "编辑框_接收"]

		[编辑框类, _编辑框_发送, "编辑框_发送"]
		[按钮类, _按钮_取可用串口, "按钮_取可用串口"]
			[XE_BNCLICK, 事件_点击_按钮_取可用串口, 1]
		[组合框类, _下拉_端口, "下拉_端口"]
			[XE_PAINT_END, 事件_绘制完成_下拉_端口, 1]
		[组合框类, _下拉_波特率, "下拉_波特率"]
		[按钮类, _Button, "Button"]
			[XE_BNCLICK, 事件_点击_Button, 1]
	
	函数 虚函数 空类型 onReadEvent(常量 字符型A* portName, 正整型 readBufferLen)// 串口接收事件  窗口继承接收事件类后 可以在窗口类下面直接写接收事件了
		//调试输出("接收数据的端口名称 ",  A2W_(portName))
		如果 (readBufferLen > 0)
			字符型A *data =new 字符型A[readBufferLen + 1] // 加上结束符 '\0' 的长度
			如果(data)
				// 读取
				整型 recLen = m_串口通讯.读取数据(data, readBufferLen)
				如果(recLen > 0)
					data[recLen] = '\0' //加上文本的结束符标志
					// 发送数据到指定的端口
					文本型  AAA = "窗口继承模式已接收到你发的数据"
					m_串口通讯.写入数据(W2A_(AAA),文本取长度(AAA)*2)
					占位

				占位
			//调试输出("接收到的数据 ", A2W_(data))
			编辑框_添加文本(元素句柄_, A2W_(data) + "\n")
			编辑框_自动滚动(元素句柄_)
			元素_重绘(元素句柄_,真)
			delete data
			data = NULL

		
			占位
						
				
				
		
		占位
		
	函数 整型 运行(文本型 窗口布局文件 = "main.xml", 炫彩句柄 父句柄 = 0)
		显示(TRUE)
		返回 0

	

	函数 整型  事件_点击_按钮_打开(逻辑型* 是否拦截)
		//打开串口按钮
		文本型A 端口号 = W2A_(_下拉_端口.取项文本(_下拉_端口.取选择项(), 0))
		调试输出(端口号)
		整型 波特率值 = 文本到整型(_下拉_波特率.取项文本(_下拉_波特率.取选择项(), 0))
		调试输出(波特率值)
		m_串口通讯.初始化串口(端口号, (串口波特率)波特率值, (串口校验)0, 串口数据位_8, 串口停止位_1, 串口流控制_无流控制, 512)

		m_串口通讯.打开串口()
		_编辑框_接收.置文本(A2W_(m_串口通讯.取版本信息()) + "\n")
		// 绑定串口数据接收事件 
		//m_串口通讯.挂接读取事件(&m_串口通讯接收事件)//绑定串口数据接收事件 无窗口模式
		m_串口通讯.挂接读取事件(本类)//绑定串口数据接收事件 窗口继承模式
		//获取接收编辑框的元素句柄 

		如果 (m_串口通讯.是否已打开())//判断串口是否已打开 打开后才能执行发送数据的功能
			消息框("串口打开成功")
					
			占位
		否则 
			消息框("请检查com端口是否存在")
			占位

		返回 0
	函数 空类型 加载界面下拉列表框数据()
		HELE 下拉_波特率_ = (HELE)炫彩_取对象从名称("下拉_波特率")   //获取下拉列表元素
		组合框_创建数据适配器(下拉_波特率_)
		_下拉_波特率.添加项文本("19200")
		_下拉_波特率.添加项文本("9600")
		_下拉_波特率.添加项文本("4800")
		_下拉_波特率.添加项文本("2400")
		_下拉_波特率.添加项文本("1200")
		组合框_置选择项(下拉_波特率_, 1)

		占位


	函数 空类型 取可用串口与加载()
		//串口信息_结构.串口信息_串口名称
		//串口信息_结构.串口信息_串口描述
		//串口信息_结构.串口信息_硬件id
		元素句柄_ = (HELE)XC_GetObjectByName("编辑框_接收")
		串口列表信息类  枚举所有串口
		动态数组<串口信息_结构>  串口信息
		串口列表到动态数组(枚举所有串口.取可用串口列表(), 串口信息)
		
		
		HELE 下拉_端口_列表 = (HELE)炫彩_取对象从名称("下拉_端口")   //获取下拉列表元素
		组合框_创建数据适配器(下拉_端口_列表)
		//组合框_添加项文本(下拉_端口_列表, "北京")
		//组合框_添加项文本(下拉_端口_列表, "上海")
		
		计次循环 整型 i = 0; 串口信息.取成员数()-1
			编辑框_添加文本(元素句柄_, A2W_(串口信息[i].串口信息_串口名称) + "\n")
			_下拉_端口.添加项文本(A2W_(串口信息[i].串口信息_串口名称))
			

			//编辑框_添加文本(元素句柄_, A2W_(串口信息[i].串口信息_硬件id) + "\n")
			编辑框_添加文本(元素句柄_, A2W_(串口信息[i].串口信息_串口描述) + "\n")
			编辑框_添加文本(元素句柄_,  "\n")
			编辑框_自动滚动(元素句柄_)
			元素_重绘(元素句柄_,真)
			pass
		组合框_置选择项(下拉_端口_列表, 0)
		元素_重绘(下拉_端口_列表, 真)


	函数 整型  事件_点击_按钮_取可用串口(元素句柄 句柄, 逻辑型* 是否拦截)
		取可用串口与加载()
		
		返回 0


	函数 整型  事件_绘制完成_下拉_端口(元素句柄 句柄, 绘图句柄 hDraw, 逻辑型* 是否拦截)
		//串口信息_结构.串口信息_串口名称
		//串口信息_结构.串口信息_串口描述
		//串口信息_结构.串口信息_硬件id
		元素句柄_ = (HELE)XC_GetObjectByName("编辑框_接收")
		串口列表信息类  枚举所有串口
		动态数组<串口信息_结构>  串口信息
		串口列表到动态数组(枚举所有串口.取可用串口列表(), 串口信息)
		
		
		HELE 下拉_端口_列表 = (HELE)炫彩_取对象从名称("下拉_端口")   //获取下拉列表元素
		组合框_创建数据适配器(下拉_端口_列表)

		
		计次循环 整型 i = 0; 串口信息.取成员数()-1
			编辑框_添加文本(元素句柄_, A2W_(串口信息[i].串口信息_串口名称) + "\n")
			_下拉_端口.添加项文本(A2W_(串口信息[i].串口信息_串口名称))
			

			//编辑框_添加文本(元素句柄_, A2W_(串口信息[i].串口信息_硬件id) + "\n")
			编辑框_添加文本(元素句柄_, A2W_(串口信息[i].串口信息_串口描述) + "\n")
			编辑框_添加文本(元素句柄_,  "\n")
			编辑框_自动滚动(元素句柄_)
			元素_重绘(元素句柄_,真)
			pass
		组合框_置选择项(下拉_端口_列表, 0)
		元素_重绘(下拉_端口_列表,真)

		返回 0
	函数 整型  事件_点击_Button(元素句柄 句柄, 逻辑型* 是否拦截)
		字符型 *数据
		如果 (m_串口通讯.是否已打开())//判断串口是否已打开 打开后才能执行发送数据的功能
			数据 =_编辑框_发送.取文本_临时()
			m_串口通讯.writeData(W2A_(数据),文本取长度(数据)*2 )//*2是为了支持中文字符的长度

			占位
		否则 
			消息框("请先打开串口")
			占位


		返回 0
	
// 这个适用于无窗口方式的串口回调返回数据
类 串口接收事件类 继承 串口数据返回类 //这种写法是通用的方式 适用于windows窗口与dll程序
	
	/// 串口通讯接收事件的回调
	函数 虚函数 空类型 onReadEvent(常量 字符型A* portName, 正整型 readBufferLen)   // 串口接收事件
		
		//调试输出("接收数据的端口名称 ",  A2W_(portName))
		如果 (readBufferLen > 0)
			字符型A *data =new 字符型A[readBufferLen + 1] // 加上结束符 '\0' 的长度
			如果(data)
				// 读取
				整型 recLen = m_串口通讯.读取数据(data, readBufferLen)
				如果(recLen > 0)
					data[recLen] = '\0' //加上文本的结束符标志
					// 发送数据到指定的端口
					文本型  AAA = "无窗口模式已接收到你发的数据"
					m_串口通讯.写入数据(W2A_(AAA),文本取长度(AAA)*2)
					占位

				占位
			//调试输出("接收到的数据 ", A2W_(data))
			编辑框_添加文本(元素句柄_, A2W_(data) + "\n")
			编辑框_自动滚动(元素句柄_)
			元素_重绘(元素句柄_,真)
			delete data
			data = NULL

			占位
				
		
		

		占位
	

	占位

	
函数 整型 入口函数_窗口()
	炫彩_初始化(TRUE)
	炫彩_加载资源文件("resource.res")
	

	我的主窗口.运行()
	我的主窗口.取可用串口与加载()
	我的主窗口.加载界面下拉列表框数据()

	炫彩_运行()
	炫彩_退出()
	返回 0
