#pragma once
//@模块名称 XM_羽蝶模块
//@版本   1.7
//@日期   2024-09-21
//@作者   羽蝶
//@QQ    2523749769
//@模块备注   XM_羽蝶模块
//羽蝶模块所有功能仅依赖【基础模块】【易语言核心模块】【COM操作】
// 【&  使用相关问题可前往QQ群: 137891495 反馈  &】
// 【&  使用相关问题可前往QQ群: 137891495 反馈  &】
// 【&  使用相关问题可前往QQ群: 137891495 反馈  &】
//【炫语言 - XM_羽蝶模块】
// 【XM_DLL注入】【XM_ETCP】【XM_Hook】【XM_编码解码】【XM_变量操作】
// 【XM_窗口操作】【XM_ASM汇编】【XM_键盘鼠标】【XM_进程操作】
// 【XM_线程操作】【XM_内存操作】【XM_网页访问】【XM_文本操作】
// 【XM_文件目录】【XM_系统操作】【XM_指针操作】【XM_驱动通信】
// 
// 【2024/09/21】 更新内容：更改分组命名，新增 类_ASM汇编,封装部分汇编命令(待完善增加)
// 
// 【2024/09/01】 更新内容：修复部分BUG，解决与炫易模块共用时发生的冲突
// 
//【2024/08/25】 更新内容：新增【XM_驱动通信】驱动通讯、加载驱动、卸载驱动 命令
// 
//【2024/08/24】 更新内容：将散开的命令整合为单个模块


//@依赖   module_base.h,module_yyy.h,module_com.h


//@隐藏{
#ifndef  XM_SYSTEM
#define  XM_SYSTEM   //防止重复包含CPP，出现重定义
//@隐藏}
#include "XM_系统操作/_module_XM_System.h" 
//@src  "XM_系统操作\XM_System.cpp"
#endif  //XM_SYSTEM
//@隐藏{
#ifndef  XM_Memory
#define  XM_Memory    //防止重复包含CPP，出现重定义
//@隐藏}
#include "XM_内存操作/_module_XM_Memory_Operations.h" 
//@src  "XM_内存操作\XM_Memory_Operations.cpp"
#endif //XM_Memory
//@隐藏{
#ifndef  XM_PROCESS
#define  XM_PROCESS    //防止重复包含CPP，出现重定义
//@隐藏}
#include "XM_进程线程/_module_XM_Process.h" 
//@src  "XM_进程线程\XM_Process.cpp"
#endif //XM_PROCESS
//@隐藏{
#ifndef  XM_Window
#define  XM_Window   //防止重复包含CPP，出现重定义
//@隐藏}
#include "XM_窗口操作/_module_XM_Window.h" 
//@src  "XM_窗口操作\XM_Window.cpp"
#endif  //XM_Window
//@隐藏{
#ifndef  XM_String
#define  XM_String   //防止重复包含CPP，出现重定义
//@隐藏}
#include "XM_文本操作/_module_XM_String.h"
//@src  "XM_文本操作\XM_String.cpp"
#endif  //XM_String
//@隐藏{
#ifndef  XM_FILE
#define  XM_FILE   //防止重复包含CPP，出现重定义
//@隐藏}
#include "XM_文件目录/_module_XM_File.h"
//@src  "XM_文件目录\XM_File.cpp"
#endif  //XM_FILE
//@隐藏{
#ifndef  XM_Var
#define  XM_Var   //防止重复包含CPP，出现重定义
//@隐藏}
#include "XM_变量操作/_module_XM_Var.h"
//@src  "XM_变量操作\XM_Var.cpp"
#endif  //XM_Var
//@隐藏{
#ifndef  XM_ASM
#define  XM_ASM   //防止重复包含CPP，出现重定义
//@隐藏}
#include "XM_汇编操作/_module_XM_Asm.h"
//@src  "XM_汇编操作\XM_Asm.cpp"
#endif  //XM_ASM
//@隐藏{
#ifndef  XM_Point
#define  XM_Point   //防止重复包含CPP，出现重定义
//@隐藏}
#include "XM_指针操作/_module_XM_Point.h"
//@src  "XM_指针操作\XM_Point.cpp"
#endif  //XM_Point
//@隐藏{
#ifndef  XM_ETCP
#define  XM_ETCP   //防止重复包含CPP，出现重定义
//@隐藏}
#include "XM_ETCP/_module_XM_ETCP.h"
//@src  "XM_ETCP\XM_ETCP.cpp"
#endif  //XM_ETCP
//@隐藏{
#ifndef  XM_EnCode
#define  XM_EnCode   //防止重复包含CPP，出现重定义
//@隐藏}
#include "XM_编码解码/_module_XM_EnCode.h"
//@src  "XM_编码解码\XM_EnCode.cpp"
#endif  //XM_编码解码
//@隐藏{
#ifndef  XM_Http
#define  XM_Http   //防止重复包含CPP，出现重定义
//@隐藏}
#include "XM_网页访问/_module_XM_Http.h"
//@src  "XM_网页访问\XM_Http.cpp"
#endif  //XM_网页访问
//@隐藏{
#ifndef  XM_Hook
#define  XM_Hook   //防止重复包含CPP，出现重定义
//@隐藏}
#include "XM_Hook/_module_XM_Hook.h"
//@src  "XM_Hook\XM_Hook.cpp"
#endif  //XM_Hook
//@隐藏{
#ifndef  XM_KeyBoadr
#define  XM_KeyBoadr   //防止重复包含CPP，出现重定义
//@隐藏}
#include "XM_键盘鼠标/_module_XM_KeyBoadr.h"
//@src  "XM_键盘鼠标\XM_KeyBoadr.cpp"
#endif  //XM_KeyBoadr
//@隐藏{
#ifndef  XM_DllInject
#define  XM_DllInject   //防止重复包含CPP，出现重定义
//@隐藏}
#include "XM_DLL注入/_module_XM_DllInject.h"
//@src  "XM_DLL注入\XM_DllInject.cpp"
#endif  //XM_DllInject
//@隐藏{
#ifndef  XM_Device
#define  XM_Device   //防止重复包含CPP，出现重定义
//@隐藏}
#include "XM_驱动通信/_module_XM_Device.h"
//@src  "XM_驱动通信\XM_Device.cpp"
#endif  //XM_Device

/*@声明


//=========================👇 👇 👇 👇 XM_DLL注入 👇 👇 👇 👇====================================


//@分组{ XM_DLL注入

//@备注   通过创建远程线程的方式注入DLL
//@返回   成功返回TRUE,失败返回FALSE
//@参数   默认-1为自身进程
//@参数   DLL完整路径
//@参数   空白文本,代表不启动任何函数
//@别名   DLL注入_线程(参_进程ID,参_注入的DLL文件名,参_DLL函数名)
BOOL InjectDLLByThread(int Pid, CXText wDllPath, CXText wFuncName = L"");   // ------------------------->>> DLL注入_线程 <<< -------------------------

//@备注   通过创建远程线程的方式注入DLL
//@返回   成功返回TRUE,失败返回FALSE
//@参数   默认-1为自身进程
//@参数   DLL完整路径
//@参数   空白文本,代表不启动任何函数
//@别名   DLL注入_线程2(参_进程句柄,参_注入的DLL文件名,参_DLL函数名)
BOOL InjectDLLByThread2(vint hProcess, CXText wDllPath, CXText wFuncName = L"");   // ------------------------->>> DLL注入_线程2 <<< -------------------------


//@备注   通过创建远程线程的方式卸载DLL,
//@返回   成功返回TRUE,失败返回FALSE
//@参数   默认-1为自身进程
//@参数   DLL完整路径
//@别名   DLL卸载_线程(参_进程ID,参_卸载的DLL文件名)
BOOL UnInjectDLLByThread(int Pid, CXText wDllPath);   // ------------------------->>> DLL卸载_线程 <<<-------------------------

//@备注   通过创建远程线程的方式卸载DLL,
//@返回   成功返回TRUE,失败返回FALSE
//@参数   默认-1为自身进程
//@参数   DLL完整路径
//@别名   DLL卸载_线程2(参_进程句柄,参_卸载的DLL文件名)
BOOL UnInjectDLLByThread2(vint hProcess, CXText wDllPath);   // ------------------------->>> DLL卸载_线程2 <<<-------------------------

//@备注   当DLL带窗口时,用这个函数初始化,可以解决窗口一闪而过的问题
//@参数   设置热键,用来呼出窗口
//@参数   这个函数会在内部回调触发
//@别名   DLL初始化_线程(参_热键,参_热键触发函数)
VOID InitDLLByThread(int dwHotKey, vint lpCallBak);   // ------------------------->>> DLL初始化_线程 <<<-------------------------

//@备注   创建进程通过修改EIP/RIP注入DLL,根据目标进程的位数不同自动处理
//@参数   参_进程全路径
//@参数   参_DLL路径
//@别名   DLL注入_创建(参_进程全路径,参_DLL路径)
BOOL InjectDLLByEIP(CXText wProcessPath, CXText wDllPath);   // ------------------------->>> DLL注入_创建 <<<-------------------------

//@备注   全局钩子注入,注意钩子注入器必须和DLL位数一致
//@返回   成功返回钩子句柄,失败返回0
//@参数   注意:DLL中只能有一个公开函数
//@参数   默认是全局注入
//@别名   DLL注入_钩子(参_DLL路径,参_线程ID)
vint InjectDLLByHook(CXText wDllPath, int dwThreadId = 0);   // ------------------------->>> DLL注入_钩子 <<<-------------------------

//@备注   全局钩子卸载
//@参数   参_钩子句柄
//@别名   DLL卸载_钩子(参_钩子句柄)
BOOL UnInjectDLLByHook(vint lphDLL);   // ------------------------->>> DLL卸载_钩子 <<<-------------------------

//@备注   发送退出消息给所有被本类所注入DLL的线程,
//@参数   参_钩子句柄
//@别名   DLL发送退出_钩子(参_钩子句柄)
BOOL SendExitMsgByHook(vint lphDLL);   // ------------------------->>> DLL发送退出_钩子 <<<-------------------------

//@备注   钩子DLL需要初始化
//@返回   此返回值需要返回给DLL的公开函数
//@参数   指定挂钩过程是否必须处理消息
//@参数   指定消息是否已从队列中删除,
//@参数   指向包含消息详细信息的MSG结构的指针
//@参数   无参数无返回值的一个子程序,当DLL初始化的时候,触发这个函数.
//@参数   无参数无返回值的一个子程序,当DLL退出或卸载时,触发这个函数
//@参数   设置呼出窗口的快捷键
//@参数   触发函数 主要用于窗口的呼出
//@参数   参_进程PID
//@别名   DLL初始化_钩子(Code,wParam,lParam,参_DLL初始化函数,参_DLL退出函数,参_热键,参_热键触发函数,参_进程PID)
vint InitDllByHook(int Code, vint wParam, vint lParam, vint 参_DLL初始化函数, vint 参_DLL退出函数, int 参_热键 = 0, vint 参_热键触发函数 = 0, int 参_进程PID = 0);

//@备注   本类主要是针对32位进程进行内存注入,DLL必须是32位
//@别名   类_内存注入x86
class XM_DllInjectMemX86
{
public:
	//@备注   注入DLL数据
//@返回   成功返回DLL的模块句柄,失败或已注入返回0。
//@参数   参_进程ID
//@参数   参_Dll数据
//@别名   注入DLL(参_进程ID,参_Dll数据)
	vint InjectDll(int dwPid, CXBytes bDllData);   // ------------------------->>> 注入DLL <<<-------------------------

	//@备注   返回已经注入到指定进程内的DLL的函数地址
//@返回   失败返回0。
//@参数   参_DLL函数名
//@别名   取DLL函数地址(参_DLL函数名)
	vint GetFuncAddr(CXText wFuncName);   // ------------------------->>> 取DLL函数地址 <<<-------------------------

	//@备注   执行已经注入到指定进程内的DLL的函数
	//@返回   成功返回所执行的函数的地址，失败返回0。
//@参数   用 取DLL函数地址 取出
//@参数   参数1
//@参数   参数2
//@参数   参数3
//@参数   参数4
//@参数   参数5
//@参数   参数6
//@参数   参数7
//@参数   参数8
//@参数   参数9
//@参数   参数10
//@参数   参数11
//@参数   参数12
//@参数   参数13
//@参数   参数14
//@参数   参数15
//@别名   执行DLL函数(参_DLL函数地址,参数2,参数3,参数4,参数5,参数6,参数7,参数8,参数9,参数10,参数11,参数12,参数13,参数14,参数15)
	vint CallFunc(vint lpFuncAddr, vint  Arg1 = 0, vint  Arg2 = 0, vint  Arg3 = 0, vint  Arg4 = 0, vint Arg5 = 0, vint Arg6 = 0, vint Arg7 = 0, vint Arg8 = 0, vint Arg9 = 0, vint Arg10 = 0, vint Arg11 = 0, vint Arg12 = 0, vint Arg13 = 0, vint Arg14 = 0, vint Arg15 = 0);

	//@备注   卸载已经注入的内存中的DLL
//@返回   成功返回TRUE,失败返回FALSE.(最好不要卸载，卸载的话被注入的进程很容易崩溃)
//@别名   卸载DLL()
	BOOL FreeDll();
};

//@备注   本类主要是针对64位进程进行内存注入,DLL必须是64位
//@别名   类_内存注入x64
class XM_DllInjectMemX64
{
public:
	//@参数   参_进程ID
//@参数   参_Dll数据
//@别名   注入DLL(参_进程ID,参_Dll数据)
	BOOL InjectDll(int dwPid, CXBytes bDllData);   // ------------------------->>> 注入DLL <<<-------------------------
};


//@别名   类_PeLoader
class XM_PeLoader
{
public:
	//@备注   加载内存DLL
//@参数   参_DLL数据
//@别名   加载(参_DLL数据)
	BOOL LoadMemDLL(CXBytes bDllData);   // ------------------------->>> 加载 <<<-------------------------

	//@备注   释放已加载的PE文件
//@别名   释放()
	BOOL FreeMemDLL();

	//@备注   返回指定函数指针
//@参数   参_函数名
//@别名   取函数(参_函数名)
	vint GetMemProcAddress(CXTextA wFuncName);   // ------------------------->>> 取函数 <<<-------------------------

	//@别名   取基址()
	vint GetMemDllBase();   // ------------------------->>> 取基址 <<<-------------------------
};

//补充完APIHOOK后 添加  【类_DLL】

//@分组} XM_DLL注入
//=========================👆 👆 👆 👆 XM_DLL注入 👆 👆 👆 👆====================================












//=========================👇 👇 👇 👇 XM_ETCP 👇 👇 👇 👇====================================
//@分组{ XM_ETCP

//@备注   使用本类前需先调用此命令初始化
//@返回   成功返回真，失败返回假
//@参数   回调模板_服务端回调
//@参数   回调模板_客户端
//@参数   假设用于配套：128最佳，假设用于标准TCP：系统默认是8192，最佳：假设客户端可能发送的最大包。空为：512。
//@别名   ETCP_初始化(服务端回调,客户端回调,内置缓冲)
BOOL InitEtcp(vint tcpfun = 0, vint tcpfunclient = 0, DWORD buflen = 512);  // -------------------------👉 ETCP__初始化 👈 -------------------------

//@备注   创建一个TCP的服务端
//@返回   成功返回服务端指针
//@参数   绑定地址
//@参数   绑定端口
//@参数   如果参数为真,只能接收ETCP自身的数据. 默认为假
//@别名   服务端_创建(绑定地址,绑定端口,配套模式)
vint CreateServer(CXText wHost = L"0.0.0.0", DWORD wPort = 8888, BOOL nIs = FALSE);  // -------------------------👉 服务端_创建 👈 -------------------------

//@备注   向服务端发送数据
//@返回   成功返回真，失败返回假
//@参数   "服务端创建"所返回的指针
//@参数   回调里的客户句柄。
//@参数   最大60M
//@参数   真:同步发送。
//@别名   服务端_发送(服务端指针,客户端句柄,数据,是否返回)
BOOL Sever2Client(vint lpServer, vint hClient, CXBytes bData, BOOL isRecv);  // -------------------------👉 服务端_发送 👈 -------------------------

//@备注   断开客户端
//@返回   成功返回真，失败返回假
//@参数   回调里的客户句柄。
//@参数   是否立即断开
//@别名   服务端_断开(客户端句柄,立即断开)
BOOL DisConnectClient(vint hClient, BOOL bIs = FALSE);  // -------------------------👉 服务端_断开 👈 -------------------------

//@备注   关闭自身
//@返回   成功返回真，失败返回假
//@参数   "服务端创建"所返回的指针
//@别名   服务端_关闭(服务端指针)
BOOL CloseServer(vint lpServer);  // -------------------------👉 服务端_关闭 👈 -------------------------

//@备注   取出服务器端口
//@返回   成功返回服务器端口
//@参数   "服务端创建"所返回的指针
//@别名   服务端_取端口(服务端指针)
DWORD GetServerPort(vint lpServer);  // -------------------------👉 服务端_取端口 👈 -------------------------

//@备注   取出服务器句柄
//@返回   成功返回服务器句柄
//@参数   "服务端创建"所返回的指针
//@别名   服务端_取句柄(服务端指针)
DWORD GetServerSock(vint lpServer);  // -------------------------👉 服务端_取句柄 👈 -------------------------

//@备注   取出服务器客户地址
//@返回   成功返回服务器客户地址
//@参数   "服务端创建"所返回的指针
//@别名   服务端_取客户地址(服务端指针,客户句柄)
DWORD GetClientIp(vint lpServer, vint hClient);  // -------------------------👉 服务端_取客户地址 👈 -------------------------

//@备注   连接到服务端
//@返回   成功返回自身指针
//@参数   服务端地址
//@参数   服务端端口
//@参数   默认：10秒
//@参数   真则配套，则只接收本模块的客户端为配用。假为任意客户端。默认：假。
//@参数   默认0，不使用代理；1：SOCKS4；2：SOCKS5；3：HTTP
//@参数   代理地址
//@参数   代理端口
//@参数   代理帐号
//@参数   代理密码
//@别名   客户端_连接(服务端地址,服务端端口,连接超时,配套模式,代理类型,代理地址,代理端口,代理帐号,代理密码)
vint ConnectServer(CXText 服务端地址, DWORD 服务端端口, DWORD 连接超时 = 10, BOOL 配套模式 = FALSE, DWORD 代理类型 = 0, CXText 代理地址 = L"", DWORD 代理端口 = 0, CXText 代理帐号 = L"", CXText 代理密码 = L"");  // -------------------------👉 客户端_连接 👈 -------------------------

//@备注   发送到服务端
//@返回   成功返回自身指针
//@参数   "客户端连接"所返回的指针。
//@参数   配套（真）最多发送65536000字节，非配套模式（假）可发送(2的31次方-1)以下字节长度
//@参数   真:同步发送。
//@参数   取空白字节集 (接收长度),不能大于65536000
//@参数   默认2秒立即返回，若2秒后收到数据，将在初始化函数内回调
//@别名   客户端_发送(客户端指针,发送数据,是否返回,返回数据,延时返回)
BOOL Client2Server(vint lpClient, CXBytes bData, BOOL bIsRecv = FALSE, CXBytes bRecvData = NULL, DWORD dwTimeOut = 2);  // -------------------------👉 客户端_发送 👈 -------------------------

//@备注   断开连接
//@返回   成功返回真，失败返回假
//@参数   "客户端连接"所返回的指针。
//@别名   客户端_断开(客户端指针)
BOOL DisconnectServer(vint lpClient);  // -------------------------👉 客户端_断开 👈 -------------------------

//@分组} XM_ETCP
//=========================👆 👆 👆 👆 XM_ETCP 👆 👆 👆 👆====================================








//=========================👇 👇 👇 👇 XM_Hook 👇 👇 👇 👇====================================
//@分组{ XM_数据类型

//@备注   类_InlineHook对应类型 主要用来保存HOOK前的数据  卸载的时候 传入即可
//@别名   内联HOOK_信息
struct InlieHook_Info
{
	//@备注   Hook地址 一般不需要操作
	//@别名   成_Hook地址
	vint lpHookAddr;
	//@备注   空白区域地址
	//@别名   成_空白地址
	vint lpNewAddr;
	//@备注   Hook的原始数据
	//@别名   成_原始数据
	CXBytes bOldBin;
	//@备注   Hook的长度
   //@别名   成_Hook长度
	vint lpHookLen;
	//@备注   保存Call的地址
   //@别名   成_Call地址
	vint lpCallAddr;
};

//@别名   超级HOOK_数据
struct SuperHook_Data
{
	//@备注   保存寄存器数据的地址 以前叫 返回地址
	//@别名   寄存器地址
	vint lpReg;
	//@备注   HOOK地址的原数据
	//@别名   原始数据
	CXBytes bOldData;
	//@备注   HOOK的地址
	//@别名   HOOK地址
	vint lpHookAddr;
	//@备注   HOOK的数据
	//@别名   HOOK数据
	CXBytes bHookData;
	//@备注   跳转的空白地址
	//@别名   空白地址
	vint lpNeWAddr;
	//@备注   保存初始化代码的地址
	//@别名   初始化地址
	vint lpIniAddr;
	//@备注   HOOK的进程ID
	//@别名   进程PID
	int dwPid;
	//@备注   HOOK的进程句柄
	//@别名   进程句柄
	vint hProcess;
	//@备注   执行完原代码后预留的空间,可以覆盖原来的代码
	//@别名   覆盖地址
	vint lpOverride;
	//@备注   回调子程序地址
	//@别名   回调地址
	vint lpCallBak;
};

//@别名   HOOK_寄存器x64
struct Hook_RegX64
{
	INT64 RAX;
	INT64 RBX;
	//@备注   在函数头部，一般这儿值表示第一个参数
	INT64 RCX;
	//@备注   在函数头部，一般这儿值表示第二个参数
	INT64 RDX;
	INT64 RBP;
	INT64 RSP;
	INT64 RSI;
	INT64 RDI;
	INT64 RIP;
	//@备注   在函数头部，一般这儿值表示第三个参数
	INT64 R8;
	//@备注   在函数头部，一般这儿值表示第四个参数
	INT64 R9;
	INT64 R10;
	INT64 R11;
	INT64 R12;
	INT64 R13;
	INT64 R14;
	INT64 R15;
};

//@别名   HOOK_寄存器x86
struct Hook_RegX86
{
	int EAX;
	int ECX;
	int EDX;
	int EBX;
	int EBP;
	int ESP;
	int ESI;
	int EDI;
};
//@分组} XM_数据类型


//@分组{ XM_Hook

//@备注   当前HOOK属于内联HOOK,可以读取,修改寄存器的值,
//需要注意的是,要根据 安装HOOK 的 参_覆盖原代码 来决定执行顺序
//如果需要HOOK一些API函数,推荐使用类_APIHOOK;
//@别名   类_内联HOOK
class InLineHook
{
public:
	//@隐藏{
	InLineHook();
	~InLineHook();
	//@隐藏}

//@备注   安装Hook,遇到call 会自动处理 不支持多级HOOK 也就是JMP的HOOK 暂不支持
//@返回   成功返回HOOK的原始数据
//@参数   参_Hook地址
//@参数   最少5个字节,多出5个字节的会自动填充Nop
//@参数   补充代码一般用来传递寄存器
// 32位,用push 寄存器,例如 push eax;
// 64位,无需传递任何参数,回调根据自己的需求参数个数即可
//@参数   32位参考 回调模板_x86;  64位参考 回调模板_x64.
//@参数   当回调子程序 返回1的时候触发这个汇编代码
//@参数   真 = 原代码->回调子程序,注意:回调子程序如果返回了1 此代码设置为真 可能会崩溃,
// 假 = 回调子程序->原代码,  默认为假.
//@别名   安装HOOK(参_Hook地址,参_Hook长度,参_补充代码,参_回调子程序,参_返回代码,参_覆盖原代码)
	InlieHook_Info	InstallHook(vint HookAddr, vint HookLen, vint HookCallBak, CXBytes AddCode = NULL, CXBytes AddRetCode = NULL, BOOL IsCover = FALSE);

	//@参数   参_Hook信息
   //@别名   卸载HOOK(参_Hook信息)
	VOID UnstallHook(InlieHook_Info hHookInfo);   // ------------------------->>> 卸载HOOK <<<-------------------------


	//@备注   局_补充代码 = {0x57,0x56,0x55,0x54,0x53,0x52,0x51,0x50}
	//@返回   返回0 表示放行 返回1 表示拦截
	//注意 子程序内返回1的时候 安装HOOK 的最后一个参数 参_覆盖原代码 建议为假
	int 回调模板_x86(int 参_EAX, int 参_ECX, int 参_EDX, int 参_EBX, int 参_ESP, int 参_EBP, int 参_ESI, int 参_EDI);

	//@备注   无需任何补充代码
	//@返回   返回0 表示放行 返回1 表示拦截
	//注意 子程序内返回1的时候 安装HOOK 的最后一个参数 参_覆盖原代码 建议为FALSE
	int 回调模板_x64(vint 参数1, vint 参数2, vint 参数3, vint 参数4, vint 参数5, vint 参数6, vint 参数7, vint 参数8, vint 参数9, vint 参数10, vint 参数11, vint 参数12, vint 参数13, vint 参数14, vint 参数15, vint 参数16);
private:
	InlieHook_Info m_HookInfo; //私成_临时保存
	BOOL m_IsX64; //私成_是否64位
};



//@备注   本类主要针对外部进行远程HOOK,目前已经支持64位和32位,
//@别名   类_超级HOOK
class SuperHook
{
public:
	//@备注   此命令直接对进程数据进行HOOK,自动处理Call,但不支持多级HOOK
	//@返回   HOOK成功返回真
	//@参数   被HOOK程序的进程ID
	//@参数   被HOOK程序要HOOK的地址
	//@参数   回调模板_超级HOOK
	//@参数   至少拦截5字节，不然会出错，大于5字节会自动Nop
	//@参数   1.窗口HOOK模式,2.线程模式,默认1, 注意:使用线程模式时,必须保持和目标进程位数一致
	//@参数   HOOK后返回HOOK处指令数据 用于暂停后可继续HOOK 本参数可以不写
	//@参数   可空 在准备跳回前 先执行 插入的代码 一般用于堆栈平衡
	//@参数   真 = 原代码->回调子程序 假 = 回调子程序->原代码  默认为假
//@别名   开始HOOK(参_进程ID,参_HOOK地址,参_回调接口,参_拦截长度,参_HOOK模式,参_拦截数据,参_插入代码,参_覆盖原代码)
	BOOL InstallHook(DWORD dwPid, vint lpHookAddr, vint lpCallBak, int dwLen, int dwType, SuperHook_Data* hHookInfo = nullptr, CXBytes bShellCode = NULL, BOOL isOverride = FALSE);

	//@备注   此命令直接对进程数据进行HOOK,自动处理Call,但不支持多级HOOK
	//@返回   HOOK成功返回真
	//@参数   被HOOK程序的进程句柄
	//@参数   被HOOK程序要HOOK的地址
	//@参数   回调模板_超级HOOK
	//@参数   至少拦截5字节，不然会出错，大于5字节会自动Nop
	//@参数   1.窗口HOOK模式,2.线程模式,默认1, 注意:使用线程模式时,必须保持和目标进程位数一致
	//@参数   HOOK后返回HOOK处指令数据 用于暂停后可继续HOOK 本参数可以不写
	//@参数   可空 在准备跳回前 先执行 插入的代码 一般用于堆栈平衡
	//@参数   真 = 原代码->回调子程序 假 = 回调子程序->原代码  默认为假
	//@别名   开始HOOK2(参_进程句柄,参_HOOK地址,参_回调接口,参_拦截长度,参_HOOK模式,参_拦截数据,参_插入代码,参_覆盖原代码)
	BOOL InstallHook2(vint hProcess, vint lpHookAddr, vint lpCallBak, int dwLen, int dwType, SuperHook_Data* hHookInfo = nullptr, CXBytes bShellCode = NULL, BOOL isOverride = FALSE);

	//@备注   检测某地址是否被HOOK
	//@参数   参_检测地址
	//@参数   参_进程PID
	//@参数   通过 取句柄 获取
	//@别名   是否Hook(参_检测地址,参_进程PID,参_进程句柄)
	BOOL IsHooked(vint lpHookAddr, int dwPid = 0, vint hProcess = 0);   // ------------------------->>> 是否Hook <<<-------------------------

   //@备注   if暂停HOOK后，可以使用本函数，继续超级HOOK。
   //@参数   通过 取句柄 获取
   //@别名   继续(参_进程句柄)
	BOOL Resume(vint hProcess);   // ------------------------->>> 继续 <<<-------------------------

   //@备注   暂停超级HOOK。
   //@参数   通过 取句柄 获取
   //@别名   暂停(参_进程句柄)
	BOOL Suspend(vint hProcess);   // ------------------------->>> 暂停 <<<-------------------------

   //@备注   卸载超级HOOK。
   //@参数   通过 取句柄 获取
   //@别名   卸载(参_进程句柄)
	BOOL Unstall(vint hProcess);   // ------------------------->>> 卸载 <<<-------------------------

	//@备注   卸载所有超级HOOK。
   //@别名   卸载HOOK()
	BOOL UnstallHook();

	//@备注   取出HOOK的进程句柄,使用即可!请勿关闭
   //@参数   通过 取句柄 获取
   //@别名   取句柄(参_进程PID)
	vint GethProcess(int dwPid);   // ------------------------->>> 取句柄 <<<-------------------------

	//@备注   读取HOOK处的32位寄存器
   //@参数   通过 取句柄 获取
   //@别名   读值x86(参_进程句柄)
	Hook_RegX86 ReadX86(vint hProcess);   // ------------------------->>> 读值x86 <<<-------------------------

	//@备注   读取HOOK处的64位寄存器
   //@参数   通过 取句柄 获取
   //@别名   读值x64(参_进程句柄)
	Hook_RegX64 ReadX64(vint hProcess);   // ------------------------->>> 读值x64 <<<-------------------------

	//@备注   修改寄存器值
   //@参数   通过 取句柄 获取
   //@参数   对寄存器写入数据
   //@参数   0.EAX,1.ECX,2.EDX,3.EBX
   //@别名   写值x86(参_进程句柄,参_写入值,参_寄存器)
	BOOL WriteX86(vint hProcess, CXBytes bData, int dwReg = 0);   // ------------------------->>> 写值x86 <<<-------------------------

	//@备注   修改寄存器值
   //@参数   通过 取句柄 获取
   //@参数   对寄存器写入数据
   //@参数   0.RAX,1.RBX,2.RCX,3.RDX,
   // 4.RBP,5.RSP,6.RSI,7.RDI,
   // 8.R8,9.R9,10.R10,11.R11,
   // 12.R12,13.R13,14.R14,15.R15;
   //@别名   写值x64(参_进程句柄,参_写入值,参_寄存器)
	BOOL WriteX64(vint hProcess, CXBytes bData, int dwReg = 0);   // ------------------------->>> 写值x64 <<<-------------------------


	//@备注   回调模板,用于参考
   //@参数   接收目标的PID,从而判断是哪个进程进行了操作
	VOID 回调模板_超级HOOK(int 参_进程PID);

private:
	static CXVector<SuperHook_Data> m_HookInfoArr;  //私成_HOOK数据
	static vint m_OldLong;  //私成_窗口过程
	static  vint m_RegRes;//私成_注册结果
	BOOL m_IsSuc;  //私成_是否成功
	BOOL m_IsX64;  //私成_是否64位

	//@别名   内部_超级Hook子类化
	vint SetHookCallBak(vint hHwnd);

	//@别名   内部_子类化回调
	static vint CallBakFunc(vint hwnd, vint Msg, vint wParam, vint lParam);

	//@别名   _以发送消息模式初始
	CXBytes InitBySendMsg(int dwPid, vint lpReg, vint lpInit, vint lpNew, vint lpCallBak, vint lpLong);

	//@别名   _以创建线程模式初始
	CXBytes InitByThread(int dwPid, vint lpReg, vint lpInit, vint lpNew, vint lpCallBak);
};

//@分组} XM_Hook
//=========================👆 👆 👆 👆 XM_Hook 👆 👆 👆 👆====================================









//=========================👇 👇 👇 👇 XM_编码解码 👇 👇 👇 👇====================================
//@分组{ XM_编码解码

//@参数   参_欲编码的文本
//@别名   编码_URL编码(参_欲编码的文本,参_不编码字母数字,参_是否UTF8)
CXText URLEncode(CXText wText);

//@参数   参_待解码的文本
//@别名   编码_URL解码(参_待解码的文本)
CXText URLDecode(CXText wText);   // ------------------------->>> 编码_URL解码 <<<-------------------------

//@备注   将UTF8数据转换到Unicode
//@参数   utf8字节集
//@别名   编码_Utf8到Unicode(utf8字节集)
CXText UTF82Unicode(CXBytes utf8Bin);   // ------------------------->>> 编码_Utf8到Unicode <<<-------------------------

//@备注   将Unicode转换到UTF8
//@参数   Unicode文本
//@别名   编码_Unicode到Utf8(Unicode文本)
CXBytes Unicode2Utf8(CXText wText);   // ------------------------->>> 编码_Unicode到Utf8 <<<-------------------------

//@备注   将Gb2312转换到UTF8
//@参数   GB2312文本
//@别名   编码_GB2312到Utf8(GB2312文本)
CXText GB23122Utf8(CXText wText);   // ------------------------->>> 编码_GB2312到Utf8 <<<-------------------------

//@备注   将UTF8数据转换到GB2312
//@参数   参_UTF8文本
//@别名   编码_Utf8到GB2312(参_UTF8文本)
CXText UTF82GB2312(CXText utf8Bin);   // ------------------------->>> 编码_Utf8到GB2312 <<<-------------------------

//@参数   Unicode
//@参数   目标编码
//@别名   Unicode到Ansi(Unicode,目标编码)
CXText Unicode2Ansi(CXBytes Unicode, int 目标编码 = 0);   // ------------------------->>> Unicode到Ansi <<<-------------------------

//@参数   Ansi
//@参数   原始编码
//@别名   Ansi到Unicode(Ansi,原始编码)
CXBytes Ansi2Unicode(CXText Ansi, int 原始编码 = 65001);   // ------------------------->>> Ansi到Unicode <<<-------------------------

//@备注   将Unicode码转换为Ansi码，成功返回转换后的文本。
//@参数   欲转换的Unicode文本，如：“&#20048&#26131&#35770&#22363”
//@别名   编码_Unicode到Ansi_文本型(参_Unicode文本)
CXText Unicode2AnsiText(CXText UnicodeText);   // ------------------------->>> 编码_Unicode到Ansi_文本型 <<<-------------------------

//@备注   将Ansi码转换为Unicode码，成功返回转换后的文本。
//@参数   欲转换的文本，如：“乐易论坛”。
//@参数   可以添加默认分隔符 例如;
//@别名   编码_Ansi到Unicode_文本型(参_Ansi文本,参_默认分隔符)
CXText Ansi2UnicodeText(CXText AnsiText, CXText 参_默认分隔符 = L"");   // ------------------------->>> 编码_Ansi到Unicode_文本型 <<< -------------------------

//@参数   提供所欲操作的BYTE$集对象
//@别名   编码_BASE64编码(参_待编码数据)
CXText Base64Encode(CXBytes bData);   // ------------------------->>> 编码_BASE64编码 <<<-------------------------

//@备注   返回本BYTE$集数据所对应的BASE64编码格式文本内容
//@参数   提供所欲操作的BYTE$集对象
//@别名   编码_BASE64编码A(参_待编码数据)
CXBytes Base64EncodeA(CXBytes bData);   // ------------------------->>> 编码_BASE64编码A <<<-------------------------

//@备注   将所指定的BASE64编码格式文本解码为对应的BYTE$集后返回
//@参数   提供所欲解码的BASE64编码文本
//@别名   编码_BASE64解码(BASE64编码文本)
CXBytes Base64Decode(CXText wData);   // ------------------------->>> 编码_BASE64解码 <<<-------------------------

//@备注   将所指定的BASE64编码格式文本解码为对应的BYTE$集后返回
//@参数   提供所欲解码的BASE64编码文本
//@别名   编码_BASE64解码A(待解码数据)
CXBytes Base64DecodeA(CXBytes bData);   // ------------------------->>> 编码_BASE64解码A <<<-------------------------

//@分组} XM_编码解码
//=========================👆 👆 👆 👆 XM_编码解码 👆 👆 👆 👆====================================









//=========================👇 👇 👇 👇 XM_变量操作 👇 👇 👇 👇====================================
//@分组{ XM_变量操作

//@备注   把逻辑型显示成整数
//@参数   参_逻辑值
//@别名   逻辑到整数(参_逻辑值)
DWORD Bool2Int(BOOL 参_逻辑值);   // ------------------------->>> 逻辑到整数 <<<-------------------------

//@备注   把逻辑型显示成文本
//@参数   参_逻辑值
//@别名   逻辑到文本(参_逻辑值)
CXText Bool2Str(BOOL 参_逻辑值);   // ------------------------->>> 逻辑到文本 <<<-------------------------

//@参数   参_字节
//@别名   字节_到无符号(参_BYTE)
USHORT Byte2Unsign(BYTE 参_BYTE);   // ------------------------->>> 字节_到无符号 <<<-------------------------

//@参数   参_短整数
//@别名   短整数_到无符号(参_短整数)
DWORD Short2Unsign(SHORT 参_短整数);   // ------------------------->>> 短整数_到无符号 <<<-------------------------

//@参数   参_整数
//@别名   整数_到无符号(参_整数)
UINT64 Int2Unsign(int 参_整数);   // ------------------------->>> 整数_到无符号 <<<-------------------------

//@别名   到字节_()
template<class T>
BYTE 到字节_(T 参_欲转换到数据) { (BYTE)参_欲转换到数据; }

//@别名   到短整数_()
template<class T>
SHORT 到短整数_(T 参_欲转换到数据) { (SHORT)参_欲转换到数据; }

//@别名   到整数_()
template<class T>
int 到整数_(T 参_欲转换到数据) { (int)参_欲转换到数据; }

//@别名   到变整数_()
template<class T>
vint 到变整数_(T 参_欲转换到数据) { (vint)参_欲转换到数据; }

//@别名   到长整数_()
template<class T>
INT64 到长整数_(T 参_欲转换到数据) { (INT64)参_欲转换到数据; }

//@别名   到小数_()
template<class T>
FLOAT 到小数_(T 参_欲转换到数据) { (FLOAT)参_欲转换到数据; }

//@别名   到双精度小数_()
template<class T>
DOUBLE 到双精度小数_(T 参_欲转换到数据) { (DOUBLE)参_欲转换到数据; }

//@参数   参_欲转换到数据
//@别名   单精度到整数_(参_欲转换到数据)
DWORD 单精度到整数_(FLOAT 参_欲转换到数据);   // ------------------------->>> 单精度到整数_ <<<-------------------------

//@备注   把字节集转换成易语言可以查看的形式
//@别名   字节集_查看()
CXText BinView(CXBytes 参_字节集数据, BOOL 参_无符号 = TRUE);   // ------------------------->>> 字节集_查看 <<<-------------------------

//@备注   将字节集用16进制表示.可以将字节集用系统标准16进制表示
//@参数   用于转换的字节集
//@参数   真 65 66 67 68;假 65666768,默认为假.
//@别名   字节集_到十六进制()
CXText Bin2Hex(CXBytes 参_原始字节集, BOOL 参_是否带空格 = FALSE, BOOL 参_是否为大写 = TRUE);   // ------------------------->>> 字节集_到十六进制 <<<-------------------------

//@备注   将一串十六进制文本还原为字节集
//@返回   还原为字节集可以将默认的16进制文本转换成字节集。如“00BFAD00”可还原为{ 0,191,173,0 }
//@参数   如“00BFAD00AFD4FD4F9E054F9FF91FC5FF2076FBAFDB071044”
//@参数   是否去掉尾部0
//@别名   字节集_还原(参_原始16进制文本)
CXBytes Hex2Bin(CXText 参_原始16进制文本, BOOL 参_是否去掉尾部0 = FALSE);  // -------------------------👉 字节集_还原 👈 -------------------------

//@备注   把字节集头尾反转
//@别名   字节集_反转()
CXBytes BinReversal(CXBytes 参_字节集数据);   // ------------------------->>> 字节集_反转 <<<-------------------------

//@备注   模糊查找字节集
//@参数   源字节集
//@参数   带*或?号代替如"FF**AA??02"16进制, 2个字符为1个字节，1必须写成01，长度不要超过整数型
//@别名   寻找字节集_模糊(参_源字节集,参_寻找的字节集,参_起始位置)
DWORD FindBinEx(CXBytes bSourceBin, CXText bFindBin, DWORD dwIndex = 0);  // -------------------------👉 寻找字节集_模糊 👈 -------------------------

//@备注   模糊查找字节集
//@参数   参_源BYTE$集
//@参数   带*或?号代替如\
//@参数   结果保存在这里
//@别名   寻找字节集_数组(参_源字节集,参_寻找的字节集,参_返回数组)
DWORD FindBinExArr(CXBytes bSourceBin, CXText bFindBin, CXVector<int>& dwArr);   // ------------------------->>> 寻找字节集_数组 <<<-------------------------

//@备注   去掉字节集首部的0
//@别名   字节集_去首部空位(参_字节集数据)
CXBytes BinDelLef(CXBytes 参_字节集数据);   // ------------------------->>> 字节集_去首部空位 <<<-------------------------

//@备注   返回文本中指定位置处字符的代码。if指定位置超出文本长度，返回0
//@参数   参_欲取字符代码的文本
//@参数   0.首位置,1,第2个位置.if本参数被省略，默认为首位置
//@别名   取代码(参_欲取字符代码的文本,参_欲取其代码的字符位置)
DWORD ASC(CXText wText, DWORD iIndex = 0);  // ------------------------->>> 取代码 <<<-------------------------

//@备注   返回文本中指定位置处字符的代码。if指定位置超出文本长度,返回0.
//@参数   参_欲取字符代码的文本
//@参数   0.首位置,1,第2个位置.if本参数被省略，默认为首位置
//@别名   取代码2(参_欲取字符代码的文本,参_欲取其代码的字符位置)
DWORD ASC2(CXText wText, DWORD iIndex = 0);   // ------------------------->>> 取代码2 <<<-------------------------

//@备注   返回一个文本，其中包含有与指定字符代码相关的字符
//@参数   参_欲取其字符的字符代码
//@别名   取字符_()
CXText Chr(BYTE 参_欲取其字符的字符代码);   // ------------------------->>> 取字符_ <<<-------------------------

template<class T>
DWORD 取数组成员数_(T 所欲操作的数组) { return 所欲操作的数组.getSize(); }

//@备注   随机数种子必须是单一的,else可能会重复,因此,尽量单一
//@参数   本参数值if为0,将使用当前计算机系统的时钟毫秒值.
//@别名   置随机数种子_(欲置入的种子数值)
VOID SetSrandOn(DWORD dwCode = 0);  // -------------------------👉 置随机数种子_ 👈 -------------------------

//@分组} XM_变量操作
//=========================👆 👆 👆 👆 XM_变量操作 👆 👆 👆 👆====================================









//=========================👇 👇 👇 👇 XM_窗口操作 👇 👇 👇 👇====================================
//@分组{ XM_数据类型

//@别名   窗口_信息
struct Window_Info
{
	//@别名   窗口句柄
	vint hwnd;
	//@别名   进程ID
	DWORD pid;
	//@别名   线程ID
	DWORD tid;
	//@别名   窗口标题
	CXText title;
	//@别名   窗口类名
	CXText className;
};

//@别名   窗口_位置
struct Window_Postion
{
	//@别名   左边
	DWORD left;
	//@别名   顶边
	DWORD top;
	//@别名   右边
	DWORD right;
	//@别名   底边
	DWORD bottom;
	//@别名   宽度
	DWORD width;
	//@别名   高度
	DWORD height;
};

//@别名   窗口_坐标
struct Window_Point
{
	int X;
	int Y;
};

//别名   热键_监视_信息
struct HotKey_Info
{
	//@别名   主键
	DWORD PrimaryKey;
	//@别名   功能键
	DWORD FuncKey;
	//@别名   回调方法
	vint HotKeyCallBak;
};




//@分组} XM_数据类型

//=====================================================================================

//@分组{ XM_窗口操作

//@备注   取焦点句柄
//@别名   窗口_取焦点句柄()
vint GetFocusHWND();  // -------------------------👉 窗口_取焦点句柄 👈 -------------------------

//@备注   成功返回一个最顶端窗口的句柄
//@别名   窗口_取顶端窗口句柄()
vint GetForegroundHWND();  // -------------------------👉 窗口_取顶端窗口句柄 👈 -------------------------

//@备注   获取屏幕的句柄
//@别名   窗口_取屏幕句柄()
vint GetDesktopHWND();  // -------------------------👉 窗口_取屏幕句柄 👈 -------------------------

//@备注   取任务栏句柄
//@别名   窗口_取任务栏句柄()
vint GetTrayHWND();  // -------------------------👉 窗口_取任务栏句柄 👈 -------------------------

//@备注   返回一个桌面的句柄
//@别名   窗口_取桌面句柄()
vint GetShellHWND();  // -------------------------👉 窗口_取桌面句柄 👈 -------------------------

//@备注   通过窗口取线程ID
//@返回   返回线程ID
//@参数   窗口句柄
//@别名   窗口_取线程ID(参_窗口句柄)
DWORD GetThreadIdByHWND(vint hwnd);  // -------------------------👉 窗口_取线程ID 👈 -------------------------

//@备注   通过窗口取进程ID
//@返回   返回进程ID
//@参数   窗口句柄
//@别名   窗口_取进程ID(参_窗口句柄)
DWORD GetPidByHWND(vint hwnd);  // -------------------------👉 窗口_取进程ID 👈 -------------------------

//@备注   取激活的窗口句柄
//@别名   窗口_取激活句柄()
vint GetActiveHWND();  // -------------------------👉 窗口_取激活句柄 👈 -------------------------

//@备注   判断指定窗口是否激活状态
//@返回   激活返回真,未激活返回假
//@参数   窗口句柄
//@别名   窗口_是否激活(参_窗口句柄)
BOOL IsActiveWindow(vint hwnd);  // -------------------------👉 窗口_是否激活 👈 -------------------------

//@备注   判断指定窗口句柄是否有效
//@返回   有效返回真,无效返回假
//@参数   窗口句柄
//@别名   窗口_句柄是否有效(参_窗口句柄)
BOOL IsValueWindow(vint hwnd);  // -------------------------👉 窗口_句柄是否有效 👈 -------------------------

//@备注   通过窗口取标题
//@参数   窗口句柄
//@别名   窗口_取标题(参_窗口句柄)
CXText GetWindowTitle(vint hwnd);  // -------------------------👉 窗口_取标题 👈 -------------------------

//@备注   通过窗口取类名
//@参数   窗口句柄
//@别名   窗口_取类名(参_窗口句柄)
CXText GetWindowClass(vint hwnd);  // -------------------------👉 窗口_取类名 👈 -------------------------

//@备注   爆力穷举窗口句柄,不得以而为之.
//@返回   成功返回窗口句柄,失败返回 - 1
//@参数   窗口标题
//@参数   窗口类名
//@别名   窗口_暴力取句柄(参_窗口标题,参_窗口类名)
vint GetHWNDForced(CXText titleText = L"", CXText className = L"");  // -------------------------👉 窗口_暴力取句柄 👈 -------------------------

//@备注   返回指定窗口的句柄
//@参数   父窗口句柄
//@参数   子窗口句柄
//@参数   窗口类名
//@参数   窗口标题
//@别名   窗口_取句柄(参_父窗口句柄,参_子窗口句柄,参_窗口类名,参_窗口标题)
vint GetHWND(vint parentHwnd = 0, vint subHwnd = 0, CXText className = L"", CXText titleText = L"");  // -------------------------👉 窗口_取句柄 👈 -------------------------

//@备注   取鼠标位置窗口句柄
//@别名   窗口_取鼠标位置句柄()
vint GetMouseHWND();  // -------------------------👉 窗口_取鼠标位置句柄 👈 -------------------------

//@备注   将指定窗口销毁
//@返回   成功返回真,失败返回假
//@参数   窗口句柄
//@别名   窗口_销毁(参_窗口句柄)
BOOL CloseWindow(vint hwnd);  // -------------------------👉 窗口_销毁 👈 -------------------------

//@备注   改指定窗口句柄的窗口标题
//@返回   成功返回真,失败返回假
//@参数   窗口句柄
//@参数   新标题
//@别名   窗口_置标题(参_窗口句柄,参_新标题)
BOOL SetWindowText_(vint hwnd, CXText newTitle);  // -------------------------👉 窗口_置标题 👈 -------------------------

//@备注   改指定窗口句柄的窗口标题
//@返回   成功返回真,失败返回假
//@参数   窗口句柄
//@参数   新标题
//@别名   窗口_置标题2(参_窗口句柄,参_新标题)
BOOL SetWindowText2_(vint hwnd, CXText newTitle);  // -------------------------👉 窗口_置标题2 👈 -------------------------

//@备注   取一个窗口的顶级句柄
//@返回   返回窗口祖句柄
//@参数   窗口句柄
//@别名   窗口_取祖句柄(参_窗口句柄)
vint GetAncestorHWND(vint hwnd);  // -------------------------👉 窗口_取祖句柄 👈 -------------------------

//@备注   取一个窗口的父句柄
//@返回   返回窗口祖句柄
//@参数   窗口句柄
//@别名   窗口_取父句柄(参_窗口句柄)
vint GetParentHWND(vint hwnd);  // -------------------------👉 窗口_取父句柄 👈 -------------------------

//@备注   判断窗口是否可见
//@返回   可见返回真,不可见返回假
//@参数   窗口句柄
//@别名   窗口_是否可见(参_窗口句柄)
BOOL IsVisibleWindow(vint hwnd);  // -------------------------👉 窗口_是否可见 👈 -------------------------

//@备注   窗口显示或隐藏
//@参数   窗口句柄
//@参数   真=显示 假=隐藏
//@别名   窗口_显示隐藏(参_窗口句柄,参_是否显示)
BOOL SetWindowShow(vint hwnd, BOOL isShow);  // -------------------------👉 窗口_显示隐藏 👈 -------------------------

//@备注   指定一个窗口的新父
//@返回   返回  前一个父窗口的句柄
//@参数   窗口句柄
//@参数   真=显示 假=隐藏
//@别名   窗口_置父(参_窗口句柄,参_是否显示)
vint SetWindowParent(vint hwnd, BOOL Isshow);  // -------------------------👉 窗口_置父 👈 -------------------------

//@备注   设置窗口在最顶端
//@参数   窗口句柄
//@参数   真=激活 假=不激活
//@别名   窗口_置顶(参_窗口句柄,参_是否激活)
BOOL SetWindowTop(vint hwnd, BOOL isActive);  // -------------------------👉 窗口_置顶 👈 -------------------------

//@备注   取窗口位置和大小
//@参数   窗口句柄
//@别名   窗口_取位置和大小(参_窗口句柄)
Window_Postion GetWindowPosSize(vint hwnd);  // -------------------------👉 窗口_取位置和大小 👈 -------------------------

//@备注   可以取窗口和控件的大小
//@参数   欲获取一个控件大小窗口句柄
//@参数   用来存放取回来的窗口宽度
//@参数   用来存放取回来的窗口高度
//@别名   窗口_取控件大小(参_窗口句柄,参_窗口的宽度,参_窗口的高度)
BOOL GetWindowSize(vint hwnd, DWORD& lpWidth, DWORD& lpLenght);  // -------------------------👉 窗口_取控件大小 👈 -------------------------

//@备注   屏蔽窗口
//@参数   窗口句柄
//@别名   窗口_屏蔽(参_窗口句柄)
BOOL DisablWindow(vint hwnd);  // -------------------------👉 窗口_屏蔽 👈 -------------------------

//@备注   取消屏蔽窗口
//@参数   窗口句柄
//@别名   窗口_取消屏蔽(参_窗口句柄)
BOOL EnablWindow(vint hwnd);  // -------------------------👉 窗口_取消屏蔽 👈 -------------------------

//@参数   控件句柄
//@别名   窗口_取滚动条位置(参_控件句柄)
Window_Point GetWindowScroll(vint hwnd);  // -------------------------👉 窗口_取滚动条位置 👈 -------------------------

//@参数   控件句柄
//@别名   窗口_置滚动条位置(参_控件句柄,参_坐标)
VOID SetWindowScroll(vint hwnd, Window_Point pPoint);  // -------------------------👉 窗口_置滚动条位置 👈 -------------------------

//@备注   取操作句柄的内容
//@参数   窗口句柄
//@别名   窗口_取内容(参_句柄)
CXText GetWindowText_(vint hwnd);  // -------------------------👉 窗口_取内容 👈 -------------------------

//@参数   窗口句柄
//@别名   窗口_取实例句柄(参_窗口句柄)
vint GetHwndLong(vint hwnd);  // -------------------------👉 窗口_取实例句柄 👈 -------------------------

//@参数   窗口句柄
//@别名   窗口_取样式(参_窗口句柄)
vint GetHwndStyle(vint hwnd);  // -------------------------👉 窗口_取样式 👈 -------------------------

//@参数   窗口句柄
//@别名   窗口_取扩展样式(参_窗口句柄)
vint GetHwndExStyle(vint hwnd);  // -------------------------👉 窗口_取扩展样式 👈 -------------------------

//@参数   窗口句柄
//@别名   窗口_取窗口ID(参_窗口句柄)
vint GetHwndId(vint hwnd);  // -------------------------👉 窗口_取窗口ID 👈 -------------------------

//@参数   窗口句柄
//@别名   窗口_取类值(参_窗口句柄)
vint GetClassValue(vint hwnd);  // -------------------------👉 窗口_取类值 👈 -------------------------

//@备注   往指定的编辑框置内指定的内容
//@参数   控件句柄
//@参数   欲写入的内容
//@别名   窗口_置控件内容(参_控件句柄,参_欲写入的内容)
BOOL SetSubWindowText(vint hwnd, CXText newText);  // -------------------------👉 窗口_置控件内容 👈 -------------------------

//@备注   隐藏或显示控件
//@返回   成功返回真；失败返回假
//@参数   控件句柄
//@参数   显示隐藏
//@别名   窗口_置控件状态(参_控件句柄,参_显示隐藏)
BOOL SetSubWindowShow(vint hwnd, BOOL isShow);  // -------------------------👉 窗口_置控件状态 👈 -------------------------

//@备注   枚举所有窗口
//@返回   返回窗口句柄数目,失败返回0
//@参数   用于接收窗口信息数组的数组变量
//@别名   窗口_枚举(参_窗口信息)
DWORD ListWindow(CXVector<Window_Info>& hwndArray);  // -------------------------👉 窗口_枚举 👈 -------------------------

//@备注   枚举所有窗口
//@别名   窗口_枚举_数组()
CXVector<vint> ListWindowArr();  // -------------------------👉 窗口_枚举_数组 👈 -------------------------

//@备注   用文本绑定函数
//@参数   描述文本
//@参数   绑定方法
//@参数   默认值代表自身进程,必须要有窗口才行哦
//@别名   窗口_绑定函数(参_描述文本,参_绑定方法,参_窗口句柄)
BOOL SetBindFunc(CXText funText, vint pFunc, vint hwnd = -1);  // -------------------------👉 窗口_绑定函数 👈 -------------------------

//@备注   通过文本取出方法地址
//@参数   描述文本
//@参数   默认值代表自身进程,必须要有窗口才行哦
//@别名   窗口_取绑定函数(参_描述文本,参_窗口句柄)
vint GetBindFunc(CXText funText, vint hwnd = -1);  // -------------------------👉 窗口_取绑定函数 👈 -------------------------

//@参数   描述文本
//@参数   默认值代表自身进程,必须要有窗口才行哦
//@别名   窗口_删除绑定函数(参_描述文本,参_窗口句柄)
vint DelBindFunc(CXText funText, vint hwnd);  // -------------------------👉 窗口_删除绑定函数 👈 -------------------------

//@备注   返回指定窗口的矩形信息
//@参数   窗口句柄
//@别名   窗口_取矩形(参_窗口句柄)
RECT GetHWNDRect(vint hwnd);  // -------------------------👉 窗口_取矩形 👈 -------------------------

//@备注   窗口_取边框宽度
//@参数   窗口句柄
//@别名   窗口_取边框宽度(参_窗口句柄)
DWORD GetHWNDFrameWidth(vint hwnd);  // -------------------------👉 窗口_取边框宽度 👈 -------------------------

//@备注   窗口_取边框高度
//@参数   窗口句柄
//@别名   窗口_取边框高度(参_窗口句柄)
DWORD GetHWNDFrameHeight(vint hwnd);  // -------------------------👉 窗口_取边框高度 👈 -------------------------

//@备注   根据指定窗口句柄或窗口标题，查询一个窗口是否存在
//@返回   成功返回窗口句柄,否则返回0
//@参数   窗口句柄或标题
//@别名   窗口_是否存在(参_窗口句柄或标题)
vint IsWindowExist(CXText hwndTitle);  // -------------------------👉 窗口_是否存在 👈 -------------------------

//@备注   取指定窗口(左上角\顶点)在屏幕中的位置
//@参数   可空,取当前窗口位置
//@别名   窗口_取控件坐标(参_窗口句柄)
Window_Point GetSubPoint(vint hwnd = -1);  // -------------------------👉 窗口_取控件坐标 👈 -------------------------

//@备注   根据窗口句柄取出窗口控件的ID
//@返回   顶级窗口将返回0
//@参数   窗口句柄
//@别名   窗口_取控件ID(参_窗口句柄)
DWORD GetSubId(vint hwnd);  // -------------------------👉 窗口_取控件ID 👈 -------------------------

//@备注   根据控件ID取出窗口句柄
//@参数   上一级的窗口句柄
//@参数   窗口_取控件ID
//@别名   窗口_控件ID取句柄(参_窗口句柄,参_欲取句柄的控件ID)
vint GetSubHwndById(vint hwnd, DWORD subId);  // -------------------------👉 窗口_控件ID取句柄 👈 -------------------------

//@备注   根据控件句柄取出控件内容
//@参数   控件句柄
//@别名   窗口_取控件内容(参_控件句柄)
CXText GetSubText(vint hwnd);  // -------------------------👉 窗口_取控件内容 👈 -------------------------

//@备注   把焦点置到指定的控件上
//@返回   成功返回真，失败返回假；
//@参数   上一级的窗口句柄
//@别名   窗口_置焦点(参_窗口句柄)
BOOL SetSubFocus(vint hwnd);  // -------------------------👉 窗口_置焦点 👈 -------------------------

//@备注   把焦点置到指定的控件上
//@返回   成功返回真，失败返回假；
//@参数   上一级的窗口句柄
//@别名   窗口_总在最前(参_窗口句柄,参_是否总在最前)
BOOL SetHWNDTop(vint hwnd, BOOL isTop);  // -------------------------👉 窗口_总在最前 👈 -------------------------

//@返回   成功返回真，失败返回假
//@参数   窗口句柄
//@参数   0 隐藏取消激活 1 还原激活 2 最小化激活 3 最大化激活 4 还原 6 最小化取消激活 7 最小化 9 还原激活
//@别名   窗口_置状态(参_窗口句柄,参_状态类型)
BOOL SetHWNDType(vint hwnd, DWORD dwType);  // -------------------------👉 窗口_置状态 👈 -------------------------

//@备注   将指定窗口最大化
//@返回   成功返回真，失败返回假
//@参数   欲最大化窗口的句柄
//@参数   如果窗口边框为[无边框]请将此参数设置为真
//@别名   窗口_最大化(参_窗口句柄,参_是否无边框)
BOOL SetHWNDMaxSzie(vint hwnd, BOOL noFrame = FALSE);  // -------------------------👉 窗口_最大化 👈 -------------------------

//@备注   修改窗口的位置和大小
//@返回   成功返回真，失败返回假
//@参数   欲改变位置和大小的窗口句柄
//@参数   窗口新的左边位置，留空不变
//@参数   窗口新的顶边位置，留空不变
//@参数   窗口的新宽度，留空不变
//@参数   窗口的高宽度，留空不变
//@别名   窗口_置位置和大小(参_窗口句柄,左边位置,顶边位置,新宽度,新高度)
BOOL SetHWNDRectSzie(vint hwnd, DWORD left = -1, DWORD top = -1, DWORD right = -1, DWORD bottom = -1);  // -------------------------👉 窗口_置位置和大小 👈 -------------------------

//@备注   主显示监视器上最大化的顶级窗口的默认宽度
//@别名   窗口_取最大宽度_无边框()
DWORD GetMetricsWidthNoFrame();  // -------------------------👉 窗口_取最大宽度_无边框 👈 -------------------------

//@备注   主显示监视器上最大化的顶级窗口的默认高度（以像素为单位）
//@别名   窗口_取最大高度_无边框()
DWORD GetMetricsHeightNoFrame();  // -------------------------👉 窗口_取最大高度_无边框 👈 -------------------------

//@备注   具有标题和大小边框的窗口的默认最大宽度，以像素为单位。该指标是指整个桌面。用户不能将窗口框架拖动到大于这些尺寸的尺寸
//@别名   窗口_取最大宽度()
DWORD GetMetricsWidth();  // -------------------------👉 窗口_取最大宽度 👈 -------------------------

//@备注   具有标题和大小边框的窗口的默认最大高度，以像素为单位。该指标是指整个桌面。用户不能将窗口框架拖动到大于这些尺寸的尺寸
//@别名   窗口_取最大高度()
DWORD GetMetricsHeight();  // -------------------------👉 窗口_取最大高度 👈 -------------------------

//@备注   根据窗口句柄取出进程路径
//@别名   窗口_取进程路径(参_窗口句柄)
CXText GetHwndPath(vint hwnd);  // -------------------------👉 窗口_取进程路径 👈 -------------------------

//@备注   在指定的窗口上写字
//@参数   可空:默认为"当前窗口"
//@参数   欲显示的文字内容
//@参数   字体
//@参数   字体大小
//@参数   字体颜色
//@参数   横坐标
//@参数   纵坐标
//@别名   窗口_写字(参_窗口句柄,参_内容,参_字体,参_字体大小,参_字体颜色,参_横坐标,参_纵坐标)
VOID WriteWindow(vint 参_窗口句柄 = 0, CXText 参_内容 = L"XM_羽蝶模块", CXText 参_字体 = L"微软雅黑", DWORD 参_字体大小 = 28, DWORD 参_字体颜色 = 255, DWORD 参_横坐标 = 0, DWORD 参_纵坐标 = 0);  // -------------------------👉 窗口_写字 👈 -------------------------

//@备注   保护自己的屏幕窗口内容不被捕获或复制
//@别名   窗口_禁止截图(参_窗口句柄,参_是否禁止)
BOOL DisableWindowPrtsc(vint hwnd, BOOL isDisable = TRUE);  // -------------------------👉 窗口_禁止截图 👈 -------------------------

//@备注   控制窗口关闭按钮,(允许/禁止)关闭窗口
//@返回   成功返回真，失败返回假
//@别名   窗口_禁止关闭(参_窗口句柄,参_是否禁止)
BOOL DisableWindowClose(vint hwnd, BOOL isClose = TRUE);  // -------------------------👉 窗口_禁止关闭 👈 -------------------------

//@备注   枚举指定句柄下的所有子窗口句柄
//@返回   返回子窗口句柄数目,失败或无子返回0
//@参数   当为空时相当于EnumWindows
//@参数   变量储存返回值
//@参数   要过滤的窗口类名
//@别名   窗口_枚举所有子窗口(参_父窗口句柄,参_子窗口数组,参_窗口类名)
DWORD ListSubWindow(vint parentHwnd, CXVector<vint>& subHwndList, CXText className = L"");  // -------------------------👉 窗口_枚举所有子窗口 👈 -------------------------

//@别名   窗口_取坐标距离(坐标1,坐标1)
DOUBLE GetPointLen(Window_Point pPoint1, Window_Point pPoint2);  // -------------------------👉 窗口_取坐标距离 👈 -------------------------

//@备注   设置子类化,返回窗口过程指针
//@别名   窗口_开始子类化(参_窗口句柄,参_回调地址)
vint BiginWidowLong(vint hwnd, vint callBak);  // -------------------------👉 窗口_开始子类化 👈 -------------------------

//@备注   恢复子类化
//@参数   窗口句柄
//@参数   窗口_开始子类化 返回的结果
//@别名   窗口_停止子类化(参_窗口句柄,参_窗口过程指针)
vint StopWidowLong(vint hwnd, vint lpPrevWndFunc);  // -------------------------👉 窗口_停止子类化 👈 -------------------------

//@备注   在子类化回调函数中使用
//@参数   WNDPROC lpPrevWndFunc 窗口_开始子类化 返回结果
//@参数   回调参数1 HWND hWnd
//@参数   回调参数2 UINT Msg
//@参数   回调参数3 WPARAM wParam
//@参数   回调参数4 LPARAM lParam
//@别名   窗口_子类化Call(参_窗口过程指针,参_窗口句柄,参_消息类型,参_消息参数1,参_消息参数2)
vint CallWidowLong(vint lpPrevWndFunc, vint hwnd, vint Msg, vint wParam, vint lParam);  // -------------------------👉 窗口_子类化Call 👈 -------------------------

//@别名   窗口_置扩展样式(参_窗口句柄,参_新样式)
vint SetWidowExStyle(vint hwnd, vint newStyle);  // -------------------------👉 窗口_置扩展样式 👈 -------------------------

//@备注   注册窗口消息
//@别名   窗口_注册消息(参_消息文本)
DWORD RegisterWindowMsg(CXText 参_消息文本);  // -------------------------👉 窗口_注册消息 👈 -------------------------

//@备注   发送消息 SendMessageW
//@参数   回调参数1 HWND hWnd
//@参数   回调参数2 UINT Msg
//@参数   回调参数3 WPARAM wParam
//@参数   回调参数4 LPARAM lParam
//@别名   窗口_发送消息(参_窗口句柄,参_消息类型,参_消息参数1,参_消息参数2)
vint SendMsg(vint hwnd, vint Msg, vint wParam, vint lParam);  // -------------------------👉 窗口_发送消息 👈 -------------------------

//@备注   让窗口进行圆角化
//@参数   要设置圆角的窗口
//@参数   一般为50
//@参数   一般为50
//@别名   窗口_圆角化(参_窗口句柄,参_圆角椭圆的宽,参_圆角椭圆的高)
VOID SetWindowRadius(vint hwnd, DWORD width = 50, DWORD lenght = 50);  // -------------------------👉 窗口_圆角化 👈 -------------------------

//@备注   让控件进行圆角化
//@参数   要设置圆角的控件句柄
//@参数   一般为50
//@参数   一般为50
//@别名   控件_圆角化(参_控件句柄,参_圆角椭圆的宽,参_圆角椭圆的高)
VOID SetCWindowRadius(vint hwnd, DWORD width = 50, DWORD lenght = 50);  // -------------------------👉 控件_圆角化 👈 -------------------------

//@分组} XM_窗口操作
//=========================👆 👆 👆 👆 XM_窗口操作 👆 👆 👆 👆====================================



//=========================👇 👇 👇 👇 XM_监视热键 👇 👇 👇 👇====================================
//@分组{ XM_监视热键

//@备注   本类主要是进行全局热键监视操作
//@别名   XM_监视热键
class XM_HotKey
{
public:
	//@备注   全局监视热键
	//@参数   函数指针地址
	//@参数   主按键代码
	//@参数   功能键代码
	//@参数   默认假,时钟监控.真=线程.仅第一次设置有效, 如果第一次是真, 后续全都是线程.同理, 第一次是假, 后续全都是时钟
	//@别名   监视热键(回调方法,主键,功能键,参_是否线程监控)
	BOOL RegisterHotKey(vint lpHotKeyCallBak, DWORD intPrimaryKey, DWORD intFuncKey = 0, BOOL  bIsThread = FALSE);

	//@备注   撤销全局热键
	//@别名   撤销监视热键()
	VOID UnRegisterHotKey();

	//@备注   热键是否按下
	//@别名   热键是否按下(参_键代码)
	BOOL IsHotKeyDown(DWORD dwHotKey);
};

//@分组} XM_监视热键
//=========================👆 👆 👆 👆 XM_监视热键 👆 👆 👆 👆====================================


//=========================👇 👇 👇 👇 XM_通用对话框 👇 👇 👇 👇====================================
//@分组{ XM_通用对话框

//@备注   本类是通用对话框操作
//@别名   XM_通用对话框
class XM_CommonDialog
{
public:
	//@备注   与通用对话框功能一样
	//@返回   成功返回文件路径
	//@参数   是否使用易语言样式
	//@参数   仅适用于打开文件和保存文件对话框
	//@参数   从本属性中读取的文件名包括驱动器符和全路径目录，同时本属性也用作初始对话框中的文件名编辑框
	//@参数   过滤器文本由单个或多个成对的文本串组成, 每对文本串的第一个描述显示形式, 如: "文本文件(*.txt)\0*.txt"
	//@参数   指定当打开对话框时所自动跳转到的目录
	//@参数   指定当用户没有输入文件的后缀名称时所自动使用的文件后缀名称
	//@参数   当类型为打开文件对话框时，如果用户指定了一个不存在的文件名称，是否提示用户即将创建它
	//@参数   当类型为打开文件对话框时，是否允许用户指定一个不存在的文件
	//@参数   是否允许用户指定一个不存在的目录
	//@参数   在对话框关闭后是否自动返回到进入对话框时的文件目录
	//@别名   打开文件(易样式,标题,文件名,过滤器,初始目录,默认文件后缀,创建时提示,文件必须存在,目录必须存在,不改变目录)
	CXText OpenFile(BOOL bIsE = FALSE, CXText wTitle = L"", CXText wFileName = L"", CXText wFilter = L"", CXText wInitialDir = L"", CXText wDefExt = L"", BOOL bIsTip = FALSE, BOOL bIsFileExist = FALSE, BOOL bIsDirExist = FALSE, BOOL bIsChange = FALSE);

	//@备注   与通用对话框功能一样
	//@返回   成功返回文件路径
	//@参数   是否使用易语言样式
	//@参数   仅适用于打开文件和保存文件对话框
	//@参数   从本属性中读取的文件名包括驱动器符和全路径目录，同时本属性也用作初始对话框中的文件名编辑框
	//@参数   过滤器文本由单个或多个成对的文本串组成, 每对文本串的第一个描述显示形式, 如: "文本文件(*.txt)\0*.txt"
	//@参数   指定当打开对话框时所自动跳转到的目录
	//@参数   指定当用户没有输入文件的后缀名称时所自动使用的文件后缀名称
	//@参数   覆盖提示
	//@参数   当类型为打开文件对话框时，是否允许用户指定一个不存在的文件
	//@参数   是否允许用户指定一个不存在的目录
	//@参数   在对话框关闭后是否自动返回到进入对话框时的文件目录
	//@别名   保存文件(易样式,标题,文件名,过滤器,初始目录,默认文件后缀,文件覆盖提示,文件必须存在,目录必须存在,不改变目录)
	CXText SaveFile(BOOL bIsE = FALSE, CXText wTitle = L"", CXText wFileName = L"", CXText wFilter = L"", CXText wInitialDir = L"", CXText wDefExt = L"", BOOL bIsTip = FALSE, BOOL bIsFileExist = FALSE, BOOL bIsDirExist = FALSE, BOOL bIsChange = FALSE);

	//@备注   显示一个文件打开对话框, 允许用户选择或输入多个所需要打开的已存在文件, 返回用户所选择或输入后的结果
	//@返回   成功返回文件路径数组
	//@参数   是否使用易语言样式
	//@参数   指定文件打开对话框的标题, 如果被省略, 则默认为"请输入欲打开的文件："
	//@参数   过滤器文本由单个或多个成对的文本串组成, 每对文本串的第一个描述显示形式, 如: "文本文件(*.txt)\0*.txt"
	//@参数   指定当打开对话框时所自动跳转到的目录, 如果被省略, 则默认为当前目录
	//@别名   保存文件(易样式,标题,过滤器,初始目录)
	CXVector<CXText> OpenFiles(BOOL bIsE = FALSE, CXText wTitle = L"请输入欲打开的文件：", CXText wFilter = L"", CXText wInitialDir = L"");
};

//@分组} XM_通用对话框
//=========================👆 👆 👆 👆 XM_通用对话框 👆 👆 👆 👆====================================


//=========================👇 👇 👇 👇 XM_窗口热键 👇 👇 👇 👇====================================
//@分组{ XM_窗口热键

//@备注   部分软件或者游戏不支持监视热键,因此, 推出窗口热键类, 利用子类化, 注册热键方式等触发热键
//@别名   XM_窗口热键
class XM_WindowHotKey
{
public:
	//@备注   注册窗口热键
	//@返回   成功返回热键ID,失败返回-1;
	//@参数   窗口句柄
	//@参数   函数指针地址
	//@参数   键代码
	//@参数   1.ALT键;2.Ctrl;4.Shift;8:Winodws; 组合功能键相加
	//@别名   注册热键(参_窗口句柄,参_回调方法,参_主键,参_功能键状态)
	DWORD RegHotKey(vint lpHwnd, vint lpHotKeyCallBak, DWORD intPrimaryKey, DWORD intFuncKey = 0);

	//@备注   卸载热键
	//@返回   成功返回真,失败返回假
	//@参数   窗口句柄
	//@参数   热键ID:注册热键返回值
	//@别名   卸载热键(参_窗口句柄,参_热键ID)
	BOOL UnHotKey(vint lpHwnd, DWORD dwKeyId);
};

//@分组} XM_窗口热键
//=========================👆 👆 👆 👆 XM_窗口热键 👆 👆 👆 👆====================================









//=========================👇 👇 👇 👇 XM_ASM汇编 👇 👇 👇 👇====================================
//@分组{ XM_ASM汇编


//@备注   支持32位、64位
//@别名   类_ASM汇编
class XM_Asm
{
public:
	//@参数   进程ID
	//@参数   汇编代码
	//@别名   调用函数(进程ID,汇编代码)
	vint 调用函数(vint ProcessID, CXBytes code); 

   //@参数   进程句柄
   //@参数   汇编代码
   //@别名   调用函数2(进程句柄,汇编代码)
	vint 调用函数2(vint handle, CXBytes code);  

   //@参数   进程句柄
   //@参数   汇编代码
   //@参数   内存地址
   //@别名   调用函数3(进程句柄,汇编代码,内存地址)
	vint 调用函数3(vint handle, CXBytes code, vint address);

   //@参数   进程句柄
   //@参数   调用地址
   //@别名   调用函数4(进程句柄,调用地址)
	vint 调用函数4(vint handle, vint address);  

   //@参数   进程句柄
   //@参数   汇编代码
   //@别名   调用函数5(进程句柄,汇编代码)
	vint 调用函数5(vint handle, CXBytes code); 

	//@备注  放在最前面，清空上一次的字节集
	VOID 置代码();

	//@备注   公用转换
	CXBytes Int2Hex(int Value, int n);  
	;
	CXBytes 取指定字节集(int 指令参数);

	//@备注   取出返回的字节集
	CXBytes 取代码();

	//@备注   对应OD汇编指令 ADD EAX,1
	CXBytes add_eax(int 常数);  

	//@备注   对应OD汇编指令 MOV EAX,1 或 MOV EAX,00401000
	CXBytes mov_eax_常数(int 参数);

	//@备注   对应OD汇编指令 ADD ECX,1
	CXBytes add_ecx(int 常数); 

	//@备注   对应OD汇编指令 ADD EDX,1
	CXBytes add_edx(int 常数);  

	//@备注   对应OD汇编指令 ADD EBX,1
	CXBytes add_ebx(int 常数);  

	//@备注   对应OD汇编指令 ADD ESP,1
	CXBytes add_esp(int 常数);  

	//@备注   对应OD汇编指令 ADD EBP,1
	CXBytes add_ebp(int 常数);   

	//@备注   对应OD汇编指令 ADD ESI,1
	CXBytes add_esi(int 常数); 

	//@备注   对应OD汇编指令 ADD EDI,1
	CXBytes add_edi(int 常数);

	//@备注   对应OD汇编指令 CALL EAX
	CXBytes call_eax();

	//@备注   对应OD汇编指令 CALL EDX
	CXBytes call_edx();

	//@备注   对应OD汇编指令 CALL EBP
	CXBytes call_ebp();

	//@备注   对应OD汇编指令 CALL ECX
	CXBytes call_ecx();

	//@备注   对应OD汇编指令 CALL EDI
	CXBytes call_edi();

	//@备注   对应OD汇编指令 CALL ESI
	CXBytes call_esi();

	//@备注   对应OD汇编指令 CALL EAX
	CXBytes call_esp();

	//@备注   对应OD汇编指令 CALL 00401000
	CXBytes call_常数(int 常数);

	//@备注   对应OD汇编指令 CALL DWORD PTR DS:[00401000]
	CXBytes call_ptr(int 常数);

	//@备注   对应OD汇编指令 RETN
	CXBytes ret();

	CXBytes je(vint 参_修改地址, vint 参_目标地址);

	//@备注   对应OD汇编指令 PUSH 1
	CXBytes push(int 常数);

	//@备注   对应OD汇编指令 PUSH DWORD PTR DS:[00401000]
	CXBytes push_dword_ptr(int 常数);

	//@备注   对应OD汇编指令 CALL EBX
	CXBytes call_ebx();






private:
	CXBytes asm代码;
};





//@备注   动态运行汇编指令,注意, 因为是动态运行, 所以, 参数需要自己赋值进去.
//@返回   根据你的汇编指令返回结果
//@参数   [注意]1.x64汇编的调用约定和x86不一样; 2.x86需要自行保存ebp环境 开头加上[push ebp / mov ebp, esp] 结尾加上[mov esp, ebp / pop ebp / ret];
//@别名   置入代码_(参_汇编指令)
vint MachineCode(CXBytes bAsmCode);  // -------------------------👉 置入代码_ 👈 -------------------------



//@备注   本类主要针对汇编进行操作
//@别名   类_汇编功能集
class XM_AsmHelper
{
public:
	//@备注   这个用来计算Call的数据
	//@参数   参_常数
	//@别名   Push(参_常数)
	CXBytes Push_Arg(vint Arg);   // ------------------------->>> Push <<<-------------------------

	//@备注   这个用来计算Call的数据
	//@参数   参_当前地址
	//@参数   参_目标地址
	//@别名   Call(参_当前地址,参_目标地址)
	CXBytes Call_Arg(vint lpStartBase, vint lpCallBase);   // ------------------------->>> Call <<<-------------------------

//@备注   这个用来计算Call的数据
//@参数   参_目标地址
//@别名   call_dword_ptr(参_目标地址)
	CXBytes call_dword_ptr(int lpCallBase);   // ------------------------->>> call_dword_ptr <<<-------------------------

//@备注   这个用来计算Call的数据
//@参数   参_当前地址
//@参数   参_目标地址
//@别名   call_qword_ptr(参_当前地址,参_目标地址)
	CXBytes call_qword_ptr(vint lpStartBase, vint lpCallBase);   // ------------------------->>> call_qword_ptr <<<-------------------------

//@备注   这个用来计算Call的数据
//@参数   参_当前地址
//@参数   参_目标地址
//@别名   Jmp(参_当前地址,参_目标地址)
	CXBytes JmpTo(vint lpStartBase, vint lpJmpBase);   // ------------------------->>> Jmp <<<-------------------------

//@备注   初始化64位寄存器环境 保护寄存器
//@别名   pushad_x64()
	CXBytes pushad_x64();   // ------------------------->>> pushad_x64 <<<-------------------------

	//@备注   恢复初始化的64位寄存器环境
//@参数   是否覆盖Rax
//@别名   popad_x64(是否覆盖Rax)
	CXBytes popad_x64(BOOL bIsRax = FALSE);   // ------------------------->>> popad_x64<<<-------------------------
};



//@分组} XM_ASM汇编
//=========================👆 👆 👆 👆 XM_ASM汇编 👆 👆 👆 👆====================================










//=========================👇 👇 👇 👇 XM_键盘鼠标 👇 👇 👇 👇====================================
//@分组{ XM_键盘鼠标

//@备注   取鼠标在屏幕中的坐标位置
//@别名   鼠标_取位置()
POINT GetMousePoint();   // -------------------------👉 鼠标_取位置 👈 -------------------------

//@返回   成功返回原窗口句柄,失败返回0
//@参数   参_窗口句柄
//@别名   鼠标_捕获(参_窗口句柄)
vint SetMouseCapture(vint hHWND);   // ------------------------->>> 鼠标_捕获 <<<-------------------------

//@别名   鼠标_释放()
BOOL ReleaseMouseCapture();    // ------------------------->>> 鼠标_释放 <<<-------------------------

//@参数   1.左键;2.右键;3.中键.
//@参数   1.单击;2.双击;3.按下;4.放开.
//@别名   鼠标_按键(参_按键,参_按键方式)
VOID ClickMouse(int dwKeyType = 1, int dwClickType = 1);   // ------------------------->>> 鼠标_按键 <<<-------------------------

//@备注   向指定窗口发送鼠标动作消息(无返回值)
//@参数   可空:为桌面句柄  接收鼠标消息窗口句柄
//@参数   可空:为原水平坐标不变  移动目标鼠标水平坐标 (注:坐标为参数一窗口句柄中的坐标)
//@参数   可空:为原垂直坐标不变  移动目标鼠标垂直坐标
//@参数   1.左键;2.右键;3.中键;4.中键上滚动;5.中键下滚动;(滚动前后请按下放开中键)
//@参数   1.单击;2.双击;3.按下;4.放开.
//@别名   鼠标_消息(参_窗口句柄,参_x,参_y,参_按键,参_按键方式)
BOOL ClickMouseEven(vint  hHWND = 0, int  dwX = 2, int  dwY = 2, int  dwKeyType = 1, int dwClickType = 1);   // ------------------------->>> 鼠标_消息 <<<-------------------------

//@备注   记录当前鼠标坐标
//@别名   鼠标_记位()
POINT BakMousePoint();   // ------------------------->>> 鼠标_记位 <<<-------------------------


//@备注   设置鼠标坐标
//@参数   可空:相对桌面移动鼠标  句柄有效则相对窗口中坐标移动
//@参数   水平坐标
//@参数   垂直坐标
//@别名   鼠标_移动(参_窗口句柄,x,y)
BOOL MouseMove(vint hHWND = 0, vint dwX = 0, vint dwY = 0);   // ------------------------->>> 鼠标_移动 <<<-------------------------

//@参数   参_鼠标位置
//@别名   鼠标_归位(参_鼠标位置)
VOID SetBakMousePoint(POINT* wpWidnowInfo = nullptr);   // ------------------------->>> 鼠标_归位 <<<-------------------------

//@备注   鼠标操作，具体请看参数的备注
//@参数   鼠标操作，具体请看参数的备注
//@参数   可空:相对桌面移动鼠标  句柄有效则相对窗口中坐标移动
//@参数   留空则取鼠标所在水平坐标
//@参数   留空则取鼠标所在垂直坐标
//@参数   1 = 鼠标左键单击；2 = 鼠标右键单击；3 = 鼠标左键按住不放；
//@别名   鼠标_单击(参_窗口句柄,x,y,类型)
VOID ClickMouseLeft(vint  hHWND = 0, vint  dwX = 0, vint  dwY = 0, int  dwType = 1);   // ------------------------->>> 鼠标_单击 <<<-------------------------

//@备注   设置鼠标指针的可视性,只能在自身窗口隐藏鼠标
//@参数   TRUE.显示;FALSE.隐藏.
//@别名   鼠标_显示隐藏(参_是否可见)
VOID XM_ShowCursor(BOOL 参_是否可见 = TRUE);   // ------------------------->>> 鼠标_显示隐藏 <<<-------------------------

//@备注   只能改自身程序的鼠标指针；
//@参数   要改鼠标的窗口句柄
//@参数   鼠标文件名路径；支持动态鼠标；
VOID 鼠标_改指针(vint 参_窗口句柄, CXText 参_鼠标文件名路径);   // ------------------------->>> 鼠标_改指针 <<<-------------------------

//@备注   取回鼠标当前在某个窗口上的坐标
//@参数   if提供窗口句柄，将返回鼠标在该窗口上的坐标；else将取出屏幕中的坐标；
POINT 鼠标_取窗口坐标(vint 参_窗口句柄 = 0);   // ------------------------->>> 鼠标_取窗口坐标 <<<-------------------------

//@返回   鼠标左右键交换
//@参数   真.交换;假.不交换
BOOL 鼠标_左右键交换(BOOL 参_是否交换);   // ------------------------->>> 鼠标_左右键交换 <<<-------------------------

//@备注   取鼠标双击间隔时间
//@返回   以毫秒为单位。最大返回值为 5000 毫秒
int 鼠标_取双击间隔时间();   // ------------------------->>> 鼠标_取双击间隔时间 <<<-------------------------

//@参数   参_键代码
//@参数   0.单击;1.按下;2.放开
VOID 键盘_单击(int 参_键代码, int 参_状态 = 0);   // ------------------------->>> 键盘_单击 <<<-------------------------


//@备注   向指定窗口句柄的窗口中发送按键消息
//@参数   可空:为桌面超级列表框句柄  接收鼠标消息窗口句柄
//@参数   参_键代码
//@参数   可空。默认为1  1=输入字符(大写) 2=输入字符(小写)  3=按下，4=放开，5=单击
//@参数   默认不启用,TRUE为启用.
VOID 键盘_消息(vint 参_窗口句柄 = 0, int 参_键代码 = 0, int 参_按键方式 = 1, BOOL 参_是否启用功能键 = FALSE);   // ------------------------->>> 键盘_消息 <<<-------------------------

//@备注   模拟一个组合按键；如:Ctrl+A
//@参数   参_键代码
//@参数   参_功能键码1
//@参数   参_功能键码2
//@参数   参_功能键码3
VOID 键盘_组合按键(int 参_键代码, int 参_功能键码1, int 参_功能键码2 = 0, int 参_功能键码3 = 0);   // ------------------------->>> 键盘_组合按键 <<<-------------------------

//@备注   取当前大小写的输入状态,
//@返回   返回TRUE为大写,返回FALSE则为小写
BOOL 键盘_取大小写状态();

//@备注   取当前小键盘的输入状态
//@返回   返回TRUE为开,返回FALSE则为关
BOOL 键盘_取小键盘状态();

//@分组} XM_键盘鼠标
//=========================👆 👆 👆 👆 XM_键盘鼠标 👆 👆 👆 👆====================================









//=========================👇 👇 👇 👇 XM_进程线程 👇 👇 👇 👇====================================
//@分组{ XM_数据类型
//@声明
struct  IO_COUNTERS
{
	//@别名   读取操作数量
	INT64 ReadOperationCount;
	//@别名   写入操作数量
	INT64 WriteOperationCount;
	//@别名   其它读写操作数量
	INT64 OtherOperationCount;
	//@别名   读取字节数
	INT64 ReadTransferCount;
	//@别名   写入字节数
	INT64 WriteTransferCount;
	//@别名   其它读写操作字节
	INT64 OtherTransferCount;
};

//@别名   进程_模块信息
struct Process_ModuleInfo
{
	//@别名   模块入口
	vint EntryPoint;
	//@别名   模块大小
	vint SizeOfImage;
	//@别名   模块句柄
	vint lpHandleofDll;
	//@别名   模块加载地址
	vint lpBaseOfDll;
	//@别名   模块文件名
	CXText szProcessName;
	//@别名   模块完整路径
	CXText lpFilename;
};
//@别名   进程_导出函数
struct Process_ExportFuncs
{
	//@别名   函数名称
	CXText szFuncName;
	//@别名   函数地址
	vint lpFuncAddr;
	//@别名   函数偏移
	vint lpFuncOffset;
	//@别名   函数序号
	vint lpFuncNum;
};
//@别名   线程_信息
struct Thread_Info
{
	//@别名   结构大小
	DWORD dwSize;
	//@别名   引用线程数
	DWORD cntUsage;
	//@别名   线程ID
	DWORD th32ThreadID;
	//@别名   父进程ID
	DWORD th32OwnerProcessID;
	//@别名   优先级
	DWORD tpBasePri;
	//@别名   更改的优先级
	DWORD tpDeltaPri;
	//@别名   保留
	DWORD dwFlags;
	//@别名   许可证
	DWORD th32AccessKey;
	//@别名   当前进程ID
	DWORD th32CurrentProcessID;
};
//@别名   进程_寄存器
struct Process_Reg
{
	//@备注   EAX
	vint RAX;
	//@备注   EBX
	vint RBX;
	//@备注   ECX
	vint RCX;
	//@备注   EDX
	vint RDX;
	//@备注   EBP
	vint RBP;
	//@备注   ESP
	vint RSP;
	//@备注   ESI
	vint RSI;
	//@备注   EDI
	vint RDI;
	//@备注   EIP
	vint RIP;
	vint R8;
	vint R9;
	vint R10;
	vint R11;
	vint R12;
	vint R13;
	vint R14;
	vint R15;
};
//@别名   进程_句柄信息
struct Process_HandleInfo
{
	//@别名   对象句柄
	vint hHandle;
	//@别名   对象名
	CXText szName;
};
//@别名   线程_上下文64
struct ContextX64
{
	BYTE P1Home[32];
	BYTE P2Home[32];
	BYTE P3Home[32];
	BYTE P4Home[32];
	BYTE P5Home[32];
	BYTE P6Home[32];
	int ContextFlags;
	int MxCsr;
	SHORT SegCs;
	SHORT SegDs;
	SHORT SegEs;
	SHORT SegFs;
	SHORT SegGs;
	SHORT SegSs;
	int EFlags;
	vint Dr0;
	vint Dr1;
	vint Dr2;
	vint Dr3;
	vint Dr6;
	vint Dr7;
	vint Rax;
	vint Rcx;
	vint Rdx;
	vint Rbx;
	vint Rsp;
	vint Rbp;
	vint Rsi;
	vint Rdi;
	vint R8;
	vint R9;
	vint R10;
	vint R11;
	vint R12;
	vint R13;
	vint R14;
	vint R15;
	vint Rip;
	DWORD FltSave;
	BYTE Header[32];
	BYTE Legacy[128];
	BYTE Xmm0[16];
	BYTE Xmm1[16];
	BYTE Xmm2[16];
	BYTE Xmm3[16];
	BYTE Xmm4[16];
	BYTE Xmm5[16];
	BYTE Xmm6[16];
	BYTE Xmm7[16];
	BYTE Xmm8[16];
	BYTE Xmm9[16];
	BYTE Xmm10[16];
	BYTE Xmm11[16];
	BYTE Xmm12[16];
	BYTE Xmm13[16];
	BYTE Xmm14[16];
	BYTE Xmm15[16];
	BYTE VectorRegister[416];
	vint VectorControl;
	vint DebugControl;
	vint LastBranchToRip;
	vint LastBranchFromRip;
	vint LastExceptionToRip;
	vint LastExceptionFromRip;
};

struct 线程_上下文FloatSave
{
	int ControlWord;
	int StatusWord;
	int TagWord;
	int ErrorOffset;
	int ErrorSelector;
	int DataOffset;
	int DataSelector;
	BYTE RegisterArea[80];
	int Cr0NpxState;
};
//@别名   线程_上下文32
struct ContextX32
{
	int ContextFlags;
	int Dr0;
	int Dr1;
	int Dr2;
	int Dr3;
	int Dr6;
	int Dr7;
	线程_上下文FloatSave FloatSave;
	int SegGs;
	int SegFs;
	int SegEs;
	int SegDs;
	int Edi;
	int Esi;
	int Ebx;
	int Edx;
	int Ecx;
	int Eax;
	int Ebp;
	int Eip;
	int SegCs;
	int EFlags;
	int Esp;
	int SegSs;
	BYTE ExtendedRegisters[512];
};


//@分组} XM_数据类型

//=====================================================================================

//@分组{ XM_进程操作

//@备注   取出自身进程伪句柄 通常返回-1
//@别名   进程_取自进程伪句柄()
vint GetCurrenthProcess_();  // -------------------------👉 进程_取自进程伪句柄 👈 -------------------------

//@备注   通过进程ID取出进程的端口
//@返回   成功返回整数数组
//@参数   要打开的进程ID
//@别名   进程_ID取端口(参_进程ID)
CXVector<int> OpenPortByPid(DWORD PID);  // -------------------------👉 进程_ID取端口 👈 -------------------------

//@备注   通过进程ID来取出进程句柄
//@返回   成功返回进程句柄,失败返回 - 1,部分进程需要权限
//@参数   要打开的进程ID
//@别名   进程_ID取句柄(参_进程ID)
vint OpenProcessByPid(vint PID);  // -------------------------👉 进程_ID取句柄 👈 -------------------------

//@备注   判断一个进程ID是否存在
//@返回   有效返回真,无效返回假
//@参数   要打开的进程ID
//@别名   进程_ID是否有效(参_进程ID)
BOOL IsPidValue(DWORD PID);  // -------------------------👉 进程_ID是否有效 👈 -------------------------

//@备注   关闭打开的进程句柄
//@返回   成功返回进程句柄,失败返回 - 1,部分进程需要权限
//@参数   要关闭的进程句柄
//@别名   进程_关闭句柄(参_进程句柄)
BOOL CloseProcessHandle(vint hProcess);  // -------------------------👉 进程_关闭句柄 👈 -------------------------

//@备注   取出自身的进程ID
//@返回   成功返回自身PID
//@别名   进程_取自进程ID()
DWORD GetCurrentPid();  // -------------------------👉 进程_取自进程ID 👈 -------------------------

//@备注   根据进程ID取出父进程PID
//@返回   成功返回父进程ID
//@参数   默认取出自身进程
//@别名   进程_取父进程ID(参_进程ID)
DWORD GetParentPid(DWORD PID = -1);  // -------------------------👉 进程_取父进程ID 👈 -------------------------

//@备注   根据进程句柄取出父进程ID
//@返回   成功返回父进程ID
//@参数   默认取出自身进程
//@别名   进程_取父进程ID2(参_进程句柄)
DWORD GetParentPid2(vint hProcess = -1);  // -------------------------👉 进程_取父进程ID2 👈 -------------------------

//@备注   根据进程ID取出父进程名字
//@返回   成功返回父进程名称
//@参数   默认取出自身进程
//@别名   进程_取父进程名(参_进程ID)
CXText GetParentName(DWORD PID = -1);  // -------------------------👉 进程_取父进程名 👈 -------------------------

//@备注   根据进程句柄取出父进程名字
//@返回   成功返回父进程名称
//@参数   默认取出自身进程
//@别名   进程_取父进程名2(参_进程句柄)
CXText GetParentName2(vint hProcess = -1);  // -------------------------👉 进程_取父进程名2 👈 -------------------------

//@备注   根据进程句柄取出父进程名字
//@返回   成功返回第一个子进程的PID,失败返回0
//@参数   -1为取自身进程
//@参数   子进程名称
//@别名   进程_取子进程ID(参_进程ID,参_子进程名)
DWORD GetSubPID(DWORD PID, CXText SubProcessName);  // -------------------------👉 进程_取子进程ID 👈 -------------------------

//@备注   根据进程句柄取出子进程
//@返回   成功返回第一个子进程的PID,失败返回0
//@参数   -1为取自身进程
//@参数   进程ID存放数组
//@别名   进程_取子进程ID2(参_进程句柄,参_子进程名)
DWORD GetSubPID2(vint hProcess, CXText subProcessName);  // -------------------------👉 进程_取子进程ID2 👈 -------------------------

//@备注   根据进程ID取出所有子进程
//@返回   成功返回第一个子进程的PID,失败返回0
//@参数   -1为取自身进程
//@参数   子进程名称
//@参数   进程名称存放数组
//@别名   进程_取子进程(参_进程ID,参_进程PID数组,参_进程名数组)
DWORD GetSubProcess(DWORD PID, CXVector<int>& SubPidArr, CXVector<CXText>& SubNameArr);  // -------------------------👉 进程_取子进程 👈 -------------------------

//@备注   根据进程句柄取出所有子进程
//@返回   成功返回第一个子进程的PID,失败返回0
//@参数   -1为取自身进程
//@参数   子进程名称
//@参数   进程名称存放数组
//@别名   进程_取子进程2(参_进程句柄,参_进程PID数组,参_进程名数组)
DWORD GetSubProcess2(vint hProcess, CXVector<int>& SubPidArr, CXVector<CXText>& SubNameArr);  // -------------------------👉 进程_取子进程2 👈 -------------------------

//@参数   默认取出自身进程
//@别名   进程_取PEB基址(参_进程ID)
vint GetPeb(DWORD PID = -1);  // -------------------------👉 进程_取PEB基址 👈 -------------------------

//@参数   默认取出自身进程
//@别名   进程_取PEB基址2(参_进程句柄)
vint GetPeb2(vint hProcess = -1);  // -------------------------👉 进程_取PEB基址2 👈 -------------------------

//@备注   暂停指定的进程
//@返回   成功返回真  失败返回假
//@参数   默认取出自身进程
//@别名   进程_暂停(参_进程ID)
BOOL SuspProcess(DWORD PID = -1);  // -------------------------👉 进程_暂停 👈 -------------------------

//@备注   暂停指定的进程
//@返回   成功返回真  失败返回假
//@参数   默认取出自身进程
//@别名   进程_暂停2(参_进程句柄)
BOOL SuspProcess2(vint hProcess = -1);  // -------------------------👉 进程_暂停2 👈 -------------------------


//@备注   恢复指定的进程
//@返回   成功返回真  失败返回假
//@参数   默认取出自身进程
//@别名   进程_恢复(参_进程ID)
BOOL ResuProcess(DWORD PID = -1);  // -------------------------👉 进程_恢复2 👈 -------------------------

//@备注   恢复指定的进程
//@返回   成功返回真  失败返回假
//@参数   默认取出自身进程
//@别名   进程_恢复2(参_进程句柄)
BOOL ResuProcess2(vint hProcess = -1);  // -------------------------👉 进程_恢复2 👈 -------------------------

//@备注   结束指定的进程
//@返回   成功返回真  失败返回假
//@参数   默认取出自身进程
//@别名   进程_结束(参_进程ID)
BOOL TerminateProcess(DWORD PID = -1);  // -------------------------👉 进程_结束 👈 -------------------------

//@备注   结束指定的进程
//@返回   成功返回真  失败返回假
//@参数   默认取出自身进程
//@别名   进程_结束2(参_进程句柄)
BOOL TerminateProcess2(vint hProcess = -1);  // -------------------------👉 进程_结束2 👈 -------------------------

//@别名   进程_开始保护()
BOOL StartProtectProcess();  // -------------------------👉 进程_开始保护 👈 -------------------------

//@别名   进程_取消保护()
BOOL StopProtectProcess();  // -------------------------👉 进程_取消保护 👈 -------------------------

//@备注   判断进程是否使用管理权限
//@返回   管理权限返回真  非管理权限返回假
//@别名   进程_是否为管理员()
BOOL IsAdmin();  // -------------------------👉 进程_是否为管理员 👈 -------------------------

//@备注   根据进程ID取出进程名,需要提升进程权限
//@返回   成功返回进程名  失败返回""
//@参数   默认取出自身进程
//@别名   进程_取进程名(参_进程ID)
CXText GetProcessName(DWORD PID = -1);  // -------------------------👉 进程_取进程名 👈 -------------------------

//@备注   根据进程句柄取出进程名,需要提升进程权限
//@返回   成功返回进程名  失败返回""
//@参数   默认取出自身进程
//@别名   进程_取进程名2(参_进程句柄)
CXText GetProcessName2(vint hProcess = -1);  // -------------------------👉 进程_取进程名2 👈 -------------------------

//@备注   根据进程ID取出进程命令行
//@返回   成功返回进程名  失败返回""
//@参数   默认取出自身进程
//@别名   进程_取命令行(参_进程ID)
CXText GetProcessCommandLine(DWORD PID = -1);  // -------------------------👉 进程_取命令行 👈 -------------------------

//@备注   根据进程句柄取出进程命令行
//@返回   成功返回进程名  失败返回""
//@参数   默认取出自身进程
//@别名   进程_取命令行2(参_进程句柄)
CXText GetProcessCommandLine2(vint hProcess = -1);  // -------------------------👉 进程_取命令行2 👈 -------------------------

//@备注   根据进程句柄取出进程PID
//@返回   成功返回进程PID
//@参数   默认为自身进程
//@别名   进程_句柄取ID(参_进程句柄)
DWORD GetPidByProcess(vint hProcess = -1);  // -------------------------👉 进程_句柄取ID 👈 -------------------------

//@返回   复制成功返回真  复制失败返回假
//@参数   要复制的源进程句柄
//@参数   要复制的源句柄
//@参数   复制目标的进程句柄
//@参数   传入变量存储新句柄
//@参数   默认继承
//@参数   可传0~2其中之一 或 位或(?,?)多个，1 = 复制出新句柄后并把源句柄关闭, 2 = 与源句柄相同的安全结构将访问权限从源句柄复制到目标句柄
//@别名   进程_复制对象句柄(参_要复制的源进程句柄,参_要复制的源句柄,参_复制目标的进程句柄,参_返回的新句柄,参_是否继承句柄,参_复制权限)
BOOL CopyProcess(vint SourceProcessHandle, vint SourceHandle, vint TargetProcessHandle, vint& TargetHandle, BOOL IsExtend = TRUE, DWORD Access = 0);  // -------------------------👉 进程_复制对象句柄 👈 -------------------------

//@备注   提升自身进程权限
//@返回   成功返回真  失败返回假
//@参数   17.备份 18.启动 19.关机 20.调试[*默认]
//@别名   进程_提升权限(参_权限标志)
BOOL AdjustProcessPrivilege(DWORD Privilege = 20);  // -------------------------👉 进程_提升权限 👈 -------------------------

//@备注   通过进程名取出进程PID
//@返回   成功.返回进程PID 失败.返回0
//@参数   进程名称
//@参数   真.区分  假.不区分[*默认]
//@别名   进程_名取ID(参_进程名,参_是否区分大小写)
DWORD GetPid(CXText ProcessName, BOOL IsCase = FALSE);  // ------------------------- 进程_名取ID  -------------------------

//@备注   根据进程名取出全部的PID
//@返回   成功.返回进程数量  失败.返回0
//@参数   进程名称
//@参数   进程ID存放数组
//@参数   真.区分  假.不区分[*默认]
//@别名   进程_取同名ID(参_进程名,参_进程PID数组,参_是否区分大小写)
DWORD GetSameNamePid(CXText ProcessName, CXVector<int>& PidArr, BOOL IsCase = FALSE);  // -------------------------👉 进程_取同名ID 👈 -------------------------

//@备注   根据进程名取出全部的PID
//@返回   成功.返回进程数量  失败.返回0
//@参数   进程名称存放数组
//@参数   进程ID存放数组
//@别名   进程_枚举(参_进程名数组,参_进程PID数组)
DWORD ListProcess(CXVector<CXText>& ProcessNameArr, CXVector<int>& PIDArr);  // -------------------------👉 进程_枚举 👈 -------------------------

//@备注   判断进程是否位64位
//@返回   真.64位,假.32位
//@参数   默认为自身进程
//@别名   进程_是否64位(参_进程名数组,参_进程PID数组)
BOOL IsX64Process(DWORD PID = -1);  // -------------------------👉 进程_是否64位 👈 -------------------------

//@备注   判断进程是否位64位
//@返回   真.64位,假.32位
//@参数   默认为自身进程
//@别名   进程_是否64位2(参_进程名数组,参_进程PID数组)
BOOL IsX64Process2(vint hProcess = -1);  // -------------------------👉 进程_是否64位2 👈 -------------------------

//@备注   在指定进程中创建一条远程线程
//@返回   成功返回线程句柄, 失败返回0
//@参数   -1为自身进程
//@参数   线程地址,没有传0
//@参数   参数地址,没有传0
//@参数   接收返回的线程ID,用于关闭此线程
//@别名   进程_创建线程(参_进程ID,参_线程地址,参_参数地址,参_线程ID)
vint CreateThreadByPid(DWORD PID, vint lpStartAddress, vint lpParameter, vint& lpThreadId);  // -------------------------👉 进程_创建线程 👈 -------------------------

//@备注   在指定进程中创建一条远程线程
//@返回   成功返回线程句柄, 失败返回0
//@参数   -1为自身进程
//@参数   线程地址,没有传0
//@参数   参数地址,没有传0
//@参数   接收返回的线程ID,用于关闭此线程
//@别名   进程_创建线程2(参_进程ID,参_线程地址,参_参数地址,参_线程ID)
vint CreateThreadByProcess(vint hProcess, vint lpStartAddress, vint lpParameter, vint& lpThreadId);  // -------------------------👉 进程_创建线程2 👈 -------------------------

//@备注   参考API CreateRemoteThread 的说明
//@参数   默认为自身进程
vint XM_CreateRemoteThread(vint hProcess, vint lpThreadAttributes, vint dwStackSize, vint lpStartAddress, vint lpParameter, vint dwCreationFlags, vint& lpThreadId);  // -------------------------👉 CreateRemoteThread_XM 👈 -------------------------

//@备注   参考API RtlCreateUserThread 的说明
vint XM_RtlCreateUserThread(vint hProcess, vint lpStartAddress, vint lpParameter, vint& lpThreadId);  // -------------------------👉 RtlCreateUserThread 👈 -------------------------

//@备注   据执行保护开关;
//@返回   成功返回真, 失败返回假
//@参数   0.全部禁用,1.全部启用,2.自动启用 适用于windows客户端,3.自动启用 适用于windows Server .
//@别名   进程_DEP保护(参_标志)
BOOL SetProcessDEP(DWORD dwFlags);  // -------------------------👉 进程_DEP保护 👈 -------------------------

//@备注   获取系统的数据执行保护 (DEP) 策略设置。
//@返回   0.全部禁用,1.全部启用,2.自动启用 适用于windows客户端,3.自动启用 适用于windows Server .
//@别名   进程_取DEP设置()
DWORD GetProcessDEP();  // -------------------------👉 进程_取DEP设置 👈 -------------------------

//@备注   获取指定进程的用户名
//@返回   成功返回用户名, 失败返回空
//@参数   默认自身进程
//@别名   进程_取用户名(参_进程ID)
CXText GetProcessUser(DWORD PID = -1);  // -------------------------👉 进程_取用户名 👈 -------------------------

//@备注   获取指定进程的用户名
//@返回   成功返回用户名, 失败返回空
//@参数   默认自身进程
//@别名   进程_取用户名2(参_进程句柄)
CXText GetProcessUser2(vint hProcess = -1);  // -------------------------👉 进程_取用户名2 👈 -------------------------

//@备注   GetTokenInformation
//@返回   查询成功返回真, 查询失败返回假
//@参数   进程_取访问令牌() 获得
//@参数   (默认填1即可)1. TokenUser,2. TokenGroups,3.  TokenPrivileges,4.  TokenOwner,5   TokenPrimaryGroup,6   TokenDefaultDacl,7   TokenSource,8   TokenType,9   TokenImpersonationLevel,
// 10  TokenStatistics,11  TokenRestrictedSids,12  TokenSessionId,13  TokenGroupsAndPrivileges,14  TokenSessionReference,15  TokenSandBoxInert,16  TokenAuditPolicy,17  TokenOrigin,
// 18  TokenElevationType,19  TokenLinkedToken,20  TokenElevation,21  TokenHasRestrictions,22  TokenAccessInformation,23  TokenVirtualizationAllowed,24  TokenVirtualizationEnabled,
// 25  TokenIntegrityLevel,26  TokenUIAccess,27  TokenMandatoryPolicy,28  TokenLogonSid,29  TokenIsAppContainer,30  TokenCapabilities,31  TokenAppContainerSid,32  TokenAppContainerNumber,
// 33  TokenUserClaimAttributes,34  TokenDeviceClaimAttributes,35  TokenRestrictedUserClaimAttributes,36  TokenRestrictedDeviceClaimAttributes,37  TokenDeviceGroups,38  TokenRestrictedDeviceGroups,
// 39  TokenSecurityAttributes,40  TokenIsRestricted,41  TokenProcessTrustLevel,42  TokenPrivateNameSpace,43  TokenSingletonAttributes,44  TokenBnoIsolation,
//45  TokenChildProcessFlags,46  TokenIsLessPrivilegedAppContainer,47  TokenIsSandboxed,48  TokenIsAppSilo,49  MaxTokenInfoClass
//@参数   返回信息的指针
//@参数   信息长度
//@参数   返回信息实际长度指针
//@别名   进程_取令牌信息2(参_令牌句柄,参_查询信息值,参_返回信息,参_返回信息长度,参_实际返回长度)
BOOL GetProcessToken(vint hToken, DWORD dwType, vint lpRetn, vint lpSize, vint lpLen);  // -------------------------👉 进程_取令牌信息2 👈 -------------------------

//@备注   OpenProcessToken
//@返回   成功返回令牌句柄, 失败返回0
//@参数   进程句柄
//@参数   TOKEN_ASSIGN_PRIMARY    (0x0001),TOKEN_DUPLICATE         (0x0002),TOKEN_IMPERSONATE       (0x0004),TOKEN_QUERY             (0x0008),TOKEN_QUERY_SOURCE      (0x0010),
// TOKEN_ADJUST_PRIVILEGES (0x0020),TOKEN_ADJUST_GROUPS     (0x0040),TOKEN_ADJUST_DEFAULT    (0x0080),TOKEN_ADJUST_SESSIONID  (0x0100),更多权限可以到 winnt.h 查看
//@别名   进程_取访问令牌2(参_进程句柄,参_访问权限)
vint OpenProToken(vint hProcess, DWORD DesiredAccess = 8);  // -------------------------👉 进程_取访问令牌2 👈 -------------------------

//@备注   指定父进程创建进程,需要提升进程权限
//@返回   成功返回进程PID, 失败返回0
//@参数   指定父进程 -1为自身进程
//@参数   完整的路径
//@别名   进程_创建_置父(参_父进程PID,参_进程全路径)
PROCESS_INFORMATION SetProcessParent(DWORD parentPid, CXText wProcessPath);  // -------------------------👉 进程_创建_置父 👈 -------------------------

//@备注   指定父进程创建进程,需要提升进程权限
//@返回   成功返回进程PID, 失败返回0
//@参数   指定父进程 -1为自身进程
//@参数   完整的路径
//@别名   进程_创建_置父2(参_父进程句柄,参_进程全路径)
PROCESS_INFORMATION SetProcessParent2(vint hProcess, CXText wProcessPath);  // -------------------------👉 进程_创建_置父2 👈 -------------------------

//@备注   创建一个程序进程,成功返回进程信息
//@返回   成功返回进程PID, 失败返回0
//@参数   欲创建进程的执行路径
//@参数   附加上程序路径后的命令行参数
//@参数   通常留空,特殊情况下使用
//@别名   进程_创建(参_程序路径,参_命令行,参_运行目录)
PROCESS_INFORMATION CreateProce(CXText wProcessPath, CXText command = "", CXText runPath = "");  // -------------------------👉 进程_创建 👈 -------------------------

//@备注   取进程优先级
//@返回   0x00000080(128).最高优先级(HIGH_PRIORITY_CLASS),0x00008000(32768).高于正常优先级(ABOVE_NORMAL_PRIORITY_CLASS),
//0x00000100(256).实时优先级(REALTIME_PRIORITY_CLASS),0x00000020(32).正常优先级(NORMAL_PRIORITY_CLASS),
// 0x00004000(16384).低于正常优先级(BELOW_NORMAL_PRIORITY_CLASS),0x00000040(64).空闲优先级(IDLE PRIORITY CLASS)
//@参数   默认自身进程
//@别名   进程_取优先级(参_进程ID)
DWORD GetProcessPriority(DWORD Pid = -1);  // -------------------------👉 进程_取优先级 👈 -------------------------

//@备注   取进程优先级
//@返回   0x00000080(128).最高优先级(HIGH_PRIORITY_CLASS),0x00008000(32768).高于正常优先级(ABOVE_NORMAL_PRIORITY_CLASS),
//0x00000100(256).实时优先级(REALTIME_PRIORITY_CLASS),0x00000020(32).正常优先级(NORMAL_PRIORITY_CLASS),
// 0x00004000(16384).低于正常优先级(BELOW_NORMAL_PRIORITY_CLASS),0x00000040(64).空闲优先级(IDLE PRIORITY CLASS)
//@参数   默认自身进程
//@别名   进程_取优先级2(参_进程ID)
DWORD GetProcessPriority2(vint hProcess = -1);  // -------------------------👉 进程_取优先级2 👈 -------------------------

//@备注   通过汇编来检测是否被调试
//@返回   被调试返回真,否则返回假
//@别名   进程_是否被调试()
BOOL IsDebugAsm();  // -------------------------👉 进程_是否被调试 👈 -------------------------

//@备注   通过NT函数检测是否被调试
//@返回   被调试返回真,否则返回假
//@参数   进程句柄,默认检测自身
//@别名   进程_是否被调试EX(参_进程句柄)
BOOL IsDebugNt(vint hProcess = 0);  // -------------------------👉 进程_是否被调试Ex 👈 -------------------------

//@备注   取出进程的IO信息
//@返回   返回进程的IO信息
//@参数   进程句柄,默认取自身
//@别名   进程_取IO信息2(参_进程句柄)
IO_COUNTERS GetProcessIO(vint hProcess = -1);  // -------------------------👉 进程_取IO信息2 👈 -------------------------

//@备注   枚举目标进程模块
//@返回   成功返回模块数量,失败返回0
//@参数   进程句柄,-1为取自身进程
//@别名   进程_取模块(参_进程ID,参_模块数组)
DWORD GetProcessModules(DWORD PID, CXVector<Process_ModuleInfo>& ModulesArr);  // -------------------------👉 进程_取模块 👈 -------------------------

//@备注   枚举目标进程模块
//@返回   成功返回模块数量,失败返回0
//@参数   进程句柄,-1为取自身进程
//@别名   进程_取模块2(参_进程句柄,参_模块数组)
DWORD GetProcessModules2(vint hProcess, CXVector<Process_ModuleInfo>& ModulesArr);   // -------------------------👉 进程_取模块2 👈 -------------------------

//@备注   取出进程模块句柄基址
//@返回   成功返回模块地址
//@参数   进程ID,-1为取自身进程
//@参数   例如game.dll
//@别名   进程_取模块基址(参_ID,参_模块名)
vint GetProcessModuleBase(DWORD PID, CXText szModuleName);  // -------------------------👉 进程_取模块基址 👈 -------------------------

//@备注   取出进程模块句柄基址
//@返回   成功返回模块地址
//@参数   进程ID,-1为取自身进程
//@参数   例如game.dll
//@别名   进程_取模块基址2(参_进程句柄,参_模块名)
vint GetProcessModuleBase2(vint hProcess, CXText szModuleName);  // -------------------------👉 进程_取模块基址2 👈 -------------------------

//@备注   取某个模块的信息
//@返回   成功返回模块信息
//@参数   进程ID,-1为取自身进程
//@参数   例如game.dll
//@别名   进程_取模块信息(参_进程ID,参_模块名)
Process_ModuleInfo GetProcessModuleInfo(DWORD PID, CXText szModuleName);  // -------------------------👉 进程_取模块信息 👈 -------------------------

//@备注   取某个模块的信息
//@返回   成功返回模块信息
//@参数   进程ID,-1为取自身进程
//@参数   例如game.dll
//@别名   进程_取模块信息2(参_进程句柄,参_模块名)
Process_ModuleInfo GetProcessModuleInfo2(vint hProcess, CXText szModuleName);  // -------------------------👉 进程_取模块信息2 👈 -------------------------

//@备注   取出自身进程的顶级窗口句柄
//@返回   成功返回自身顶级窗口句柄,失败返回桌面句柄
//@参数   默认取出自身顶级窗口句柄
//@别名   进程_取窗口句柄(参_进程ID)
vint GetProcessWindow(DWORD Pid = -1);   // -------------------------👉 进程_取窗口句柄 👈 -------------------------

//@备注   取出进程路径
//@返回   成功返回进程路径
//@参数   默认取出自身进程
//@别名   进程_取路径(参_进程ID)
CXText GetProcessPath(DWORD Pid = -1);  // -------------------------👉 进程_取路径 👈 -------------------------

//@备注   取出进程路径
//@返回   成功返回进程路径
//@参数   默认取出自身进程
//@别名   进程_取路径2(参_进程句柄)
CXText GetProcessPath2(vint hProcess = -1);  // -------------------------👉 进程_取路径2 👈 -------------------------

//@备注   取出指定进程的DLL导出函数信息
//@返回   成功返回函数数量,失败返回0
//@参数   -1为取出自身进程
//@别名   进程_取导出函数(参_进程ID,参_模块地址,参_导出函数列表)
DWORD GetExportFuncs(DWORD Pid, vint ModuleBase, CXVector<Process_ExportFuncs>& ExportFuncsArr);  // -------------------------👉 进程_取导出函数 👈 -------------------------

//@备注   取出指定进程的DLL导出函数信息
//@返回   成功返回函数数量,失败返回0
//@参数   -1为取出自身进程
//@别名   进程_取导出函数2(参_进程句柄,参_模块地址,参_导出函数列表)
DWORD GetExportFuncs2(vint hProcess, vint ModuleBase, CXVector<Process_ExportFuncs>& ExportFuncsArr);  // -------------------------👉 进程_取导出函数2 👈 -------------------------

//@备注   取出指定进程的DLL导出函数信息
//@返回   成功返回函数数量,失败返回0
//@参数   -1为取出自身进程
//@别名   进程_取导出函数Ex(参_进程句柄,参_模块名,参_导出函数列表)
DWORD GetExportFuncsEx(DWORD Pid, CXText ModuleName, CXVector<Process_ExportFuncs>& ExportFuncsArr);  // -------------------------👉 进程_取导出函数Ex 👈 -------------------------

//@备注   取出指定进程的DLL导出函数信息
//@返回   成功返回函数数量,失败返回0
//@参数   -1为取出自身进程
//@别名   进程_取导出函数Ex2(参_进程句柄,参_模块名,参_导出函数列表)
DWORD GetExportFuncsEx2(vint hProcess, CXText ModuleName, CXVector<Process_ExportFuncs>& ExportFuncsArr);  // -------------------------👉 进程_取导出函数Ex2 👈 -------------------------

//@备注   取出进程的函数地址
//@返回   成功返回函数地址,失败返回0
//@参数   -1为取出自身进程
//@别名   进程_取函数地址(参_进程ID,参_模块名,参_函数名)
vint GetProcessProcAddr(DWORD Pid, CXText ModuleName, CXText FuncName);  // -------------------------👉 进程_取函数地址 👈 -------------------------

//@备注   取出进程的函数地址
//@返回   成功返回函数地址,失败返回0
//@参数   -1为取出自身进程
//@别名   进程_取函数地址2(参_进程句柄,参_模块名,参_函数名)
vint GetProcessProcAddr2(vint hProcess, CXText ModuleName, CXText FuncName);  // -------------------------👉 进程_取函数地址2 👈 -------------------------

//@备注   使用 ZwCreateThreadEx 进行调用 创建运行的远程线程
//@返回   -1表示失败
//@参数   -1为取出自身进程
//@参数    自己生成的shellCode 或者汇编代码
//@别名   进程_调用汇编代码(参_进程ID,参_ShellCode)
vint CallProcessFunc(DWORD Pid, CXBytes ShellCode);  // -------------------------👉 进程_调用汇编代码 👈 -------------------------

//@备注   使用 ZwCreateThreadEx 进行调用 创建运行的远程线程
//@返回   -1表示失败
//@参数   -1为取出自身进程
//@参数    自己生成的shellCode 或者汇编代码
//@别名   进程_调用汇编代码2(参_进程句柄,参_ShellCode)
vint CallProcessFunc2(vint hProcess, CXBytes ShellCode);  // -------------------------👉 进程_调用汇编代码2 👈 -------------------------

//@备注   使用 ZwCreateThreadEx + CallWindowProcW 进行调用 创建运行的远程线程
//@返回   -1表示失败
//@参数   -1为取出自身进程
//@参数    自己生成的shellCode 或者汇编代码
//@别名   进程_调用汇编代码_(参_进程ID,参_ShellCode)
vint CallProcessFunc_(DWORD Pid, CXBytes ShellCode);  // -------------------------👉 进程_调用汇编代码_ 👈 -------------------------

//@备注   使用 ZwCreateThreadEx + CallWindowProcW 进行调用 创建运行的远程线程
//@返回   -1表示失败
//@参数   -1为取出自身进程
//@参数    自己生成的shellCode 或者汇编代码
//@别名   进程_调用汇编代码2_(参_进程句柄,参_ShellCode)
vint CallProcessFunc2_(vint hProcess, CXBytes ShellCode);  // -------------------------👉 进程_调用汇编代码2_ 👈 -------------------------

//@备注   取出模块的PEB
//@参数   -1为取出自身进程
//@参数    模块基址
//@别名   进程_取模块PEB(参_进程ID,参_模块基址)
vint GetModulePeb(DWORD Pid, vint  ModuleBase);  // -------------------------👉 进程_取模块PEB 👈 -------------------------

//@备注   取出模块的PEB
//@参数   -1为取出自身进程
//@参数    模块基址
//@别名   进程_取模块PEB2(参_进程句柄,参_模块基址)
vint GetModulePeb2(vint hProcess, vint ModuleBase);  // -------------------------👉 进程_取模块PEB2 👈 -------------------------

//@备注   取出模块的入口
//@参数   -1为取出自身进程
//@参数    模块基址
//@别名   进程_取模块入口(参_进程ID,参_模块基址)
vint GetModuleEntryPoint(DWORD Pid, vint  ModuleBase);  // -------------------------👉 进程_取模块入口 👈 -------------------------

//@备注   取出模块的入口
//@参数   -1为取出自身进程
//@参数    模块基址
//@别名   进程_取模块入口2(参_进程句柄,参_模块基址)
vint GetModuleEntryPoint2(vint hProcess, vint ModuleBase);  // -------------------------👉 进程_取模块入口2 👈 -------------------------

//@备注   取出指定进程的ID
//@返回   成功返回主线程ID
//@参数   默认自身进程
//@参数   真.主模块,假.第一条线程,默认假
//@别名   进程_取主线程ID(参_进程ID,参_是否主模块)
vint GetMainThread(DWORD Pid = -1, BOOL  IsMainModule = FALSE);  // -------------------------👉 进程_取主线程ID 👈 -------------------------

//@备注   取出指定进程的ID
//@返回   成功返回主线程ID
//@参数   默认自身进程
//@参数   真.主模块,假.第一条线程,默认假
//@别名   进程_取主线程ID2(参_进程句柄,参_是否主模块)
DWORD GetMainThread2(vint hProcess = -1, BOOL IsMainModule = FALSE);  // -------------------------👉 进程_取主线程ID2 👈 -------------------------

//@备注   调用进程的函数
//@参数   默认自身进程
//@参数   参_函数地址
//@参数   目标是64位时,所有寄存器有效,
//@参数   参数1
//@参数   参数2
//@参数   参数3
//@参数   参数4
//@参数   参数5
//@参数   参数6
//@参数   参数7
//@参数   参数8
//@参数   参数9
//@参数   参数10
//@参数   参数11
//@参数   参数12
//@参数   参数13
//@参数   参数14
//@参数   参数15
//@别名   进程_调用函数(参_进程句柄,参_函数地址,参_寄存器,参数1,参数2,参数3,参数4,参数5,参数6,参数7,参数8,参数9,参数10,参数11,参数12,参数13,参数14,参数15)
vint InvokeProcessFunc(DWORD Pid, vint FuncAddr, Process_Reg* ProcessReg = nullptr, vint  Arg1 = 0, vint  Arg2 = 0, vint  Arg3 = 0, vint  Arg4 = 0, vint Arg5 = 0, vint Arg6 = 0, vint Arg7 = 0, vint Arg8 = 0, vint Arg9 = 0, vint Arg10 = 0, vint Arg11 = 0, vint Arg12 = 0, vint Arg13 = 0, vint Arg14 = 0, vint Arg15 = 0);

//@备注   调用进程的函数
//@参数   默认自身进程
//@参数   参_函数地址
//@参数   目标是64位时,所有寄存器有效,
//@参数   参数1
//@参数   参数2
//@参数   参数3
//@参数   参数4
//@参数   参数5
//@参数   参数6
//@参数   参数7
//@参数   参数8
//@参数   参数9
//@参数   参数10
//@参数   参数11
//@参数   参数12
//@参数   参数13
//@参数   参数14
//@参数   参数15
//@别名   进程_调用函数2(参_进程句柄,参_函数地址,参_寄存器,参数1,参数2,参数3,参数4,参数5,参数6,参数7,参数8,参数9,参数10,参数11,参数12,参数13,参数14,参数15)
vint InvokeProcessFunc2(vint hProcess, vint FuncAddr, Process_Reg* ProcessReg = nullptr, vint  Arg1 = 0, vint  Arg2 = 0, vint  Arg3 = 0, vint  Arg4 = 0, vint Arg5 = 0, vint Arg6 = 0, vint Arg7 = 0, vint Arg8 = 0, vint Arg9 = 0, vint Arg10 = 0, vint Arg11 = 0, vint Arg12 = 0, vint Arg13 = 0, vint Arg14 = 0, vint Arg15 = 0);

//@备注   通过互斥体关闭句柄
//@返回   关闭成功返回真,关闭失败返回假
//@参数   -1为自身进程
//@参数   互斥体名
//@别名   互斥体_关闭(参_进程ID,参_互斥体名)
BOOL CloseMutex(DWORD Pid, CXText MutexName);  // -------------------------👉 互斥体_关闭 👈 -------------------------

//@备注   通过互斥体关闭句柄
//@返回   关闭成功返回真,关闭失败返回假
//@参数   -1为自身进程
//@参数   互斥体名
//@别名   互斥体_关闭2(参_进程句柄,参_互斥体名)
BOOL CloseMutex2(vint hProcess, CXText MutexName);  // -------------------------👉 互斥体_关闭2 👈 -------------------------


//@备注   关闭枚举句柄
//@返回   关闭成功返回真,关闭失败返回假
//@参数   -1为自身进程
//@参数   对象句柄
//@别名   进程_关闭枚举句柄(参_进程ID,参_对象句柄)
BOOL CloseListHandle(DWORD Pid, vint hHandle);   // -------------------------👉 进程_关闭枚举句柄 👈 -------------------------

//@备注   关闭枚举句柄
//@返回   关闭成功返回真,关闭失败返回假
//@参数   -1为自身进程
//@参数   对象句柄
//@别名   进程_关闭枚举句柄2(参_进程句柄,参_对象句柄)
BOOL CloseListHandle2(vint hProccess, vint hHandle);   // -------------------------👉 进程_关闭枚举句柄2 👈 -------------------------

//@备注   枚举进程内的句柄
//@返回   成功返回句柄数量,失败返回0
//@参数   -1为自身进程
//@参数   接收句柄信息的结构体变量
//@别名   进程_枚举句柄(参_进程ID,参_句柄列表)
DWORD ListHandle(DWORD Pid, CXVector<Process_HandleInfo>& lpProcessHandleInfoArr);  // -------------------------👉 进程_枚举句柄 👈 -------------------------

//@备注   枚举进程内的句柄
//@返回   成功返回句柄数量,失败返回0
//@参数   -1为自身进程
//@参数   接收句柄信息的结构体变量
//@别名   进程_枚举句柄2(参_进程句柄,参_句柄列表)
DWORD ListHandle2(vint hProcess, CXVector<Process_HandleInfo>& lpProcessHandleInfoArr);  // -------------------------👉 进程_枚举句柄2 👈 -------------------------



//@分组} XM_进程操作
//=========================👆 👆 👆 👆 XM_进程操作 👆 👆 👆 👆====================================



//=========================👇 👇 👇 👇 XM_线程操作 👇 👇 👇 👇====================================
//@分组{ XM_线程操作

//@备注   启动一条线程
//@返回   成功返回线程句柄,失败返回0
//@参数   函数地址
//@参数   向函数中传递一个参数,没有参数传0即可
//@参数   注意,这里需要传递一个变量用来接收返回的线程ID
//@别名   线程_启动(参_线程首地址,参_传递的参数,参_线程ID)
vint StartThread(vint lpStartAddress, vint lpParameter, vint& lpThreadId);  // -------------------------👉 线程_启动 👈 -------------------------

//@备注   ZwCreateThreadEx 重写 CreateThread
//@别名   CreateNewThread
vint CreateNewThread(vint lpThreadAttributes, vint dwStackSize, vint lpStartAddress, vint lpParameter, vint dwCreationFlags, vint& lpThreadId);

//@备注   暂停线程
//@返回   成功返回真,失败返回假
//@参数   线程句柄
//@别名   线程_暂停(参_线程句柄)
BOOL SuspendThread_(vint hThreadId);   // -------------------------👉 线程_暂停 👈 -------------------------

//@备注   恢复线程
//@返回   成功返回真,失败返回假
//@参数   线程句柄
//@别名   线程_恢复(参_线程句柄)
BOOL ResumeThread_(vint hThreadId);  // -------------------------👉 线程_恢复 👈 -------------------------

//@备注   通过线程句柄取出进程ID
//@返回   成功返回进程ID
//@参数   线程句柄
//@别名   线程_句柄取PID(参_线程句柄)
DWORD GetPidByTHandle(vint hThreadId);  // -------------------------👉 线程_句柄取PID 👈 -------------------------

//@备注   取64位进程的线程上下文
//@返回   成功返回真,失败返回假, 获取失败, 请先暂停线程,如果暂停也获取失败, 请看参数2说明
//@参数   线程句柄
// //@参数   ContextFlags = 65567  ContextFlags = 65543  参数的成员设置为以上2个值都可以获取成功
//@别名   线程_取上下文64(参_线程句柄,参_线程上下文)
BOOL GetContextThreadX64(vint hThreadId, ContextX64& ctX64);  // -------------------------👉 线程_取上下文64 👈 -------------------------

//@备注   置线程上下文,自动判断目标进程, 64位寄存器保存在R开头, 例如Rax
//@返回   成功返回真,失败返回假.
//@参数   线程句柄
//@参数   ContextFlags = 65567  ContextFlags = 65543  参数的成员设置为以上2个值都可以获取成功
//@别名   线程_置上下文64(参_线程句柄,参_线程上下文)
BOOL SetContextThreadX64(vint hThreadId, ContextX64& ctX64);  // -------------------------👉 线程_置上下文64 👈 -------------------------

//@备注   取32位进程的线程上下文
//@返回   成功返回真,失败返回假, 获取失败, 请先暂停线程,如果暂停也获取失败, 请看参数2说明
//@参数   线程句柄
// //@参数   ContextFlags = 65567  ContextFlags = 65543  参数的成员设置为以上2个值都可以获取成功
//@别名   线程_取上下文32(参_线程句柄,参_线程上下文)
BOOL GetContextThreadX86(vint hThread, ContextX32& ctX86);  // -------------------------👉 线程_取上下文32 👈 -------------------------

//@备注   置32位进程的线程上下文
//@返回   成功返回真,失败返回假.
//@参数   线程句柄
//@参数   ContextFlags = 65567  ContextFlags = 65543  参数的成员设置为以上2个值都可以获取成功
//@别名   线程_置上下文32(参_线程句柄,参_线程上下文)
BOOL SetContextThreadX86(vint hThreadId, ContextX32& ctX86);  // -------------------------👉 线程_置上下文32 👈 -------------------------

//@备注   通过线程句柄取出线程ID
//@参数   线程句柄
//@别名   线程_句柄取ID(参_线程句柄)
DWORD GetTidByHandle(vint hThreadId);  // -------------------------👉 线程_句柄取ID 👈 -------------------------

//@备注   取当前线程ID
//@别名   线程_取自线程ID()
DWORD GetSlefTid();  // -------------------------👉 线程_取自线程ID 👈 -------------------------

//@备注   通过汇编来取当前线程ID
//@别名   线程_取自线程ID2()
DWORD GetSlefTid2();  // -------------------------👉 线程_取自线程ID2 👈 -------------------------

//@备注   取当前线程伪句柄
//@别名   线程_取自线程句柄()
vint GetSlefhThread();  // -------------------------👉 线程_取自线程句柄 👈 -------------------------

//@备注   关闭已经打开的线程句柄
//@返回   成功返回真 失败返回假
//@参数   要关闭的线程句柄
//@别名   线程_关闭句柄(参_线程句柄)
BOOL ClosehThread(vint hThread);  // -------------------------👉 线程_关闭句柄 👈 -------------------------

//@备注   结束指定的进程
//@返回   成功 返回真  失败 返回假
//@参数   要结束的线程句柄
//@别名   线程_结束(参_线程句柄)
BOOL TerminatehThread(vint hThread);  // -------------------------👉 线程_结束 👈 -------------------------

//@备注   等待一个线程
//@返回   返回真表示线程运行结束，返回假表示已超时
//@参数   要等待的线程句柄
//@参数   留空，则无限等待
//@参数   默认假,真自动添加处理事件
//@别名   线程_等待(参_线程句柄,参_超时,参_是否在UI线程)
BOOL WaiteThread(vint hThread, DWORD Time = -1, BOOL IsUi = FALSE);   // -------------------------👉 线程_等待 👈 -------------------------

//@备注   等待一个线程
//@返回   返回真表示线程运行结束，返回假表示已超时
//@参数   要等待的线程句柄
//@参数   留空，则无限等待
//@别名   线程_等待2(参_线程句柄,参_超时)
DWORD WaiteThread2(vint hThread, INT64 Time = -1);  // -------------------------👉 线程_等待2 👈 -------------------------

//@备注   通过线程句柄取出线程返回值
//@参数   要取返回值的线程句柄
//@别名   线程_取返回值(参_线程句柄)
vint GetThreadRet(vint hThread);  // -------------------------👉 线程_取返回值 👈 -------------------------

//@备注   取线程的执行状态
//@返回   0.表示线程不存在或已关闭,1.执行完毕,2.正在运行.
//@参数   要取状态的线程句柄
//@别名   线程_取状态(参_线程句柄)
vint GetThreadSta(vint hThread);  // -------------------------👉 线程_取状态 👈 -------------------------

//@备注   设置/绑定CPU执行.某些情况避免主线程卡死
//@返回   成功返回真,失败返回假
//@参数   要置CPU亲和性的线程句柄
//@别名   线程_置CPU亲和性(参_线程句柄,参_亲和性参数)
BOOL SetThreadAff(vint hThread, int dwAff = 0);  // -------------------------👉 线程_置CPU亲和性 👈 -------------------------

//@备注   有时执行线程的时候,会自动关闭,可以在多线程的程序里创建COM对象前先初始化,一个线程只能调用一次
//@别名   线程_初始化COM库()
VOID InitCom();  // -------------------------👉 线程_初始化COM库 👈 -------------------------

//@备注   取消COM库的初始化,如果你在线程头部加入了 线程_初始化COM库 请在尾部加入此命令
//@别名   线程_取消COM库()
VOID UnititCom();  // -------------------------👉 线程_取消COM库 👈 -------------------------

//@备注   创建一个线程许可证
//@返回   成功返回真,失败返回假
//@参数   传入许可证的指针,通过& 或者 取变量地址获取
//@别名   线程_创建许可证(参_许可证)
BOOL InitCritical(vint License);  // -------------------------👉 线程_创建许可证 👈 -------------------------

//@备注   进入许可区
//@返回   成功返回真,失败一般就直接崩
//@参数   传入许可证的指针,通过& 或者 取变量地址获取
//@别名   线程_进入许可区(参_许可证)
BOOL UninitCritical(vint License);  // -------------------------👉 线程_进入许可区 👈 -------------------------

//@备注   尝试进入许可区
//@返回   成功返回真,失败返回假
//@参数   传入许可证的指针,通过& 或者 取变量地址获取
//@别名   线程_尝试进入许可区(参_许可证)
BOOL TryEnterCritical(vint lpCritical);  // -------------------------👉 线程_尝试进入许可区 👈 -------------------------

//@备注   进入之后必须退出,否则下次进入必崩
//@返回   成功返回真,失败返回假
//@参数   传入许可证的指针,通过& 或者 取变量地址获取
//@别名   线程_退出许可区(参_许可证)
BOOL LeaveCritical(vint lpCritical);  // -------------------------👉 线程_退出许可区 👈 -------------------------

//@备注   删除由"线程_创建许可证"命令所创建返回的进入许可证
//@返回   成功返回真,失败返回假
//@参数   传入许可证的指针,通过& 或者 取变量地址获取
//@别名   线程_删除许可证(参_许可证)
BOOL DelCritical(vint lpCritical);   // -------------------------👉 线程_删除许可证 👈 -------------------------

//@备注   成功返回线程句柄
//@参数   线程ID
//@别名   线程_打开(参_线程ID)
vint OpenThread_(vint Tid);  // -------------------------👉 线程_打开 👈 -------------------------

//@备注   取出线程的入口地址
//@参数   线程ID
//@别名   线程_取入口(参_线程ID)
vint GetThreadEntry(DWORD Tid);  // -------------------------👉 线程_取入口 👈 -------------------------

//@备注   取出线程的入口地址
//@参数   线程ID
//@别名   线程_取入口2(参_线程句柄)
vint GetThreadEntry2(vint hThread);  // -------------------------👉 线程_取入口2 👈 -------------------------

//@备注   枚举指定进程的线程
//@返回   成功返回线程数量,失败返回0
//@参数   -1为取自身进程
//@参数   接收线程属性的结构体变量
//@别名   线程_枚举线程(参_进程ID,参_线程属性)
DWORD ListThreads(DWORD Tid, CXVector<Thread_Info>& thThreadInfoArr);  // -------------------------👉 线程_枚举线程 👈 -------------------------

//@备注   枚举指定进程的线程
//@返回   成功返回线程数量,失败返回0
//@参数   -1为取自身进程
//@参数   接收线程属性的结构体变量
//@别名   线程_枚举线程2(参_进程句柄,参_线程属性)
DWORD ListThreads2(vint hProcess, CXVector<Thread_Info>& thThreadInfoArr);  // -------------------------👉 线程_枚举线程2 👈 -------------------------

//@备注   取出线程TEB
//@返回   成功返回线程Teb,需要注意的是, 如果当前进程是64位, 目标是32位的话, 返回的是指针, 要再读取一次
//@参数   线程句柄
//@别名   线程_TEB(参_线程ID)
vint GetTEB(DWORD Tid);  // -------------------------👉 线程_取TEB 👈 -------------------------

//@备注   取出线程TEB
//@返回   成功返回线程Teb,需要注意的是, 如果当前进程是64位, 目标是32位的话, 返回的是指针, 要再读取一次
//@参数   线程句柄
//@别名   线程_TEB2(参_线程句柄)
vint GetTEB2(vint hThread);  // -------------------------👉 线程_取TEB2 👈 -------------------------

//@备注   取出线程优先级
//@返回   0.正常优先级;1.优先1点;  -1.低于优先级1点;2.优先2点;  -2.低于优先级2点;15.调整进程优先级; -15.调整进程优先级;
//@参数   线程ID
//@别名   线程_取优先级(参_线程ID)
DWORD GetThreadPriority_(int Tid);  // -------------------------👉 线程_取优先级 👈 -------------------------

//@备注   设置线程优先级
//@返回   成功返回真,失败返回假
//@参数   线程ID
//@参数   0.正常优先级;1.优先1点;  -1.低于优先级1点;2.优先2点;  -2.低于优先级2点;3.调整进程优先级; -3.调整进程优先级;
//@别名   线程_置优先级(参_线程ID,参_优先级等级)
BOOL SetThreadPriority_(int Tid, int dwThreadPriority);  // -------------------------👉 线程_置优先级 👈 -------------------------

//@备注   取出线程优先级
//@返回   0.正常优先级;1.优先1点;  -1.低于优先级1点;2.优先2点;  -2.低于优先级2点;15.调整进程优先级; -15.调整进程优先级;
//@参数   线程句柄
//@别名   线程_取优先级2(参_线程句柄)
DWORD GetThreadPriority2_(vint hThread);  // -------------------------👉 线程_取优先级2 👈 -------------------------

//@备注   设置线程优先级
//@返回   成功返回真,失败返回假
//@参数   线程句柄
//@参数   0.正常优先级;1.优先1点;  -1.低于优先级1点;2.优先2点;  -2.低于优先级2点;3.调整进程优先级; -3.调整进程优先级;
//@别名   线程_置优先级2(参_线程句柄,参_优先级等级)
BOOL SetThreadPriority2_(vint hThread, int dwThreadPriority);  // -------------------------👉 线程_置优先级2 👈 -------------------------

//@备注   禁止线程产生调试事件
//@返回   成功返回真,失败返回假
//@参数   线程ID
//@别名   线程_禁止调试(参_线程ID)
BOOL DisableThreadDebug(int Tid);   // -------------------------👉 线程_禁止调试 👈 -------------------------

//@备注   禁止线程产生调试事件
//@返回   成功返回真,失败返回假
//@参数   线程句柄
//@别名   线程_禁止调试2(参_线程句柄)
BOOL DisableThreadDebug2(vint hThread);   // -------------------------👉 线程_禁止调试2 👈 -------------------------

//@分组} XM_线程操作
//=========================👆 👆 👆 👆 XM_线程操作 👆 👆 👆 👆====================================








//=========================👇 👇 👇 👇 XM_内存读写 👇 👇 👇 👇====================================
//@分组{ XM_数据类型
//@声明
//@别名   内存_属性
struct MEMORY_BASIC_INFORMATION {
	//@别名 分区地址
	PVOID BaseAddress;
	//@别名 分配地址
	PVOID AllocationBase;
	//@别名 初始属性
	DWORD AllocationProtect;
	//@别名 分区ID
	WORD PartitionId;
	//@别名 区域长度
	SIZE_T RegionSize;
	//@别名 保留值
	DWORD State;
	//@别名 保护属性
	// 1.无访问权限; 2.只读; 4.读写; 8.只读, 写 + 复制; 16(0x10).执行; 32(0x20).读 + 执行; 64(0x40).读 + 写 + 执行; 128(0x80).执行 + 写复制; 256(0x100).防护; 512(0x200).无缓存; 1024(0x400).写com;
	DWORD Protect;
	//@别名 页类型
	DWORD Type;
};


//@分组} XM_数据类型

//=====================================================================================

//@分组{ XM_内存读写

//@备注   在当前进程申请一块堆内存 GlobalAlloc
//@返回   成功返回申请到的内存地址
//@别名   申请内存_全局(参_申请的长度)
vint GlobalAlloc_(vint dwLen = 8);  // -------------------------👉 申请内存_全局 👈 -------------------------

//@备注   在当前进程申请一块堆内存 LocalAlloc
//@返回   成功返回申请到的内存地址
//@别名   申请内存_局部(参_申请的长度)
vint LocalAlloc_(vint dwLen = 8);   // -------------------------👉 申请内存_局部 👈 -------------------------

//@备注   在当前进程申请一块堆内存 HeapAlloc
//@返回   成功返回申请到的内存地址
//@别名   申请内存_(参_申请的长度)
vint HeapAlloc_(vint dwLen = 8);  // -------------------------👉 申请内存_ 👈 -------------------------

//@备注   在当前进程申请一块堆内存 HeapReAlloc
//@返回   成功返回申请到的内存地址
//@别名   申请内存附近_(参_附近指针,参_申请的长度)
vint HeapReAlloc_(vint lpMem, vint dwLen = 8);  // -------------------------👉 申请内存附近_ 👈 -------------------------

//@备注   释放堆内存  HeapFree
//@返回   成功返回真,失败返回假
//@别名   释放内存_(参_释放的内存地址)
BOOL HeapFree_(vint lpBase);  // -------------------------👉 释放内存_ 👈 -------------------------

//@备注   在当前进程申请一块堆内存 并且 写入指定的字节集
//@返回   成功返回申请到的内存地址
//@别名   申请内存_字节集(参_写入的字节集)
vint HeapAllocBin(CXBytes bData);  // -------------------------👉 申请内存_字节集 👈 -------------------------

//@备注   在当前进程申请一块堆内存 并且 写入指定的整数
//@参数   参_写入数据
//@别名   申请内存_整数(参_写入数据)
vint HeapAllocInt(DWORD iData);   // ------------------------->>> 申请内存_整数 <<<-------------------------

//@备注   在当前进程申请一块堆内存 并且 写入指定的整数
//@参数   参_写入数据
//@别名   申请内存_变整数(参_写入数据)
vint HeapAllocIntP(vint ipData);   // ------------------------->>> 申请内存_变整数 <<<-------------------------

//@备注   在当前进程申请一块堆内存 并且 写入指定的文本
//@参数   参_写入数据
//@别名   申请内存_文本(参_写入数据)
vint HeapAllocText(CXText wData);   // ------------------------->>> 申请内存_文本 <<<-------------------------

//@备注   取内存属性
//@返回   成功返回真,失败返回假
//@参数   -1默认取自身进程
//@参数   内存地址
//@参数   这个参数用来接收属性
//@别名   内存_取属性(参_进程ID,参_内存地址,参_内存属性)
BOOL GetMemoryAttr(DWORD, vint, MEMORY_BASIC_INFORMATION&);  // -------------------------👉 内存_取属性 👈 -------------------------

//@备注   取内存属性
//@返回   成功返回真,失败返回假
//@参数   -1默认取自身进程
//@参数   内存地址
//@参数   这个参数用来接收属性
//@别名   内存_取属性2(参_进程句柄,参_内存地址,参_内存属性)
BOOL  GetMemoryAttr2(vint, vint, MEMORY_BASIC_INFORMATION&);  // -------------------------👉 内存_取属性2 👈 -------------------------

//@备注   取内存属性
//@返回   成功返回真,失败返回假
//@参数   内存地址
//@参数   这个参数用来接收属性
//@别名   内存_取自属性(参_内存地址,参_内存属性)
BOOL GetSelfMemoryAttr(vint lpBase, MEMORY_BASIC_INFORMATION lpMemoryInfo);  // -------------------------👉 内存_取自属性 👈 -------------------------

//@备注   置内存属性
//@返回   成功返回真,失败返回假
//@参数   -1默认取自身进程
//@参数   内存地址
//@参数   修改长度
//@参数   默认可读可写可执行,1.无访问权限,2.只读,4.读写,8.只读, 写 + 复制, 16(0x10).执行, 32(0x20).读 + 执行, 64(0x40).读 + 写 + 执行, 128(0x80).执行 + 写复制, 256(0x100).防护, 512(0x200).无缓存, 1024(0x400).写com
//@参数  传入指针,用来接收原属性
//@别名   内存_置属性(参_进程ID,参_内存地址,参_修改长度,参_内存属性,参_原属性)
BOOL SetMemoryAttr(DWORD dwPid, vint lpBase, vint dwLen = 0, vint dwAttr = 64, vint* lpOldAttr = 0);  // -------------------------👉 内存_置属性 👈 -------------------------

//@备注   置内存属性
//@返回   成功返回真,失败返回假
//@参数   -1默认取自身进程
//@参数   内存地址
//@参数   修改长度
//@参数   默认可读可写可执行,1.无访问权限,2.只读,4.读写,8.只读, 写 + 复制, 16(0x10).执行, 32(0x20).读 + 执行, 64(0x40).读 + 写 + 执行, 128(0x80).执行 + 写复制, 256(0x100).防护, 512(0x200).无缓存, 1024(0x400).写com
// @参数  传入指针,用来接收原属性
//@别名   内存_置属性2(参_进程句柄,参_内存地址,参_修改长度,参_内存属性,参_原属性)
BOOL SetMemoryAttr2(vint hProcess, vint lpBase, vint dwLen = 0, vint dwAttr = 64, vint* lpOldAttr = 0);  // -------------------------👉 内存_置属性2 👈 -------------------------

//@备注   置内存属性
//@返回   成功返回真,失败返回假
//@参数   内存地址
//@参数   修改长度
//@参数   默认可读可写可执行,1.无访问权限,2.只读,4.读写,8.只读, 写 + 复制, 16(0x10).执行, 32(0x20).读 + 执行, 64(0x40).读 + 写 + 执行, 128(0x80).执行 + 写复制, 256(0x100).防护, 512(0x200).无缓存, 1024(0x400).写com
// @参数  传入指针,用来接收原属性
//@别名   内存_置自属性(参_进程句柄,参_内存地址,参_修改长度,参_内存属性,参_原属性)
BOOL SetSelfMemAttr(vint lpBase, vint dwLen = 0, vint dwAttr = 64, vint* lpOldAttr = 0);  // -------------------------👉 内存_置自属性 👈 -------------------------

//@返回   成功返回字节数据,失败返回-1
//@别名   内存_读字节(参_进程ID,参_内存地址)
BYTE ReadProcessByte(DWORD dwPid, vint lpBase);  // -------------------------👉 内存_读字节 👈 -------------------------

//@返回   成功返回短整型数据,失败返回-1
//@别名   内存_读短整数(参_进程ID,参_内存地址)
SHORT ReadProcessShort(DWORD dwPid, vint lpBase);  // -------------------------👉 内存_读短整数 👈 -------------------------

//@返回   成功返回整型数据,失败返回-1
//@别名   内存_读整数(参_进程ID,参_内存地址)
INT ReadProcessInt(DWORD dwPid, vint lpBase);  // -------------------------👉 内存_读整数 👈 -------------------------

//@返回   成功返回单浮点数据,失败返回-1
//@别名   内存_读小数(参_进程ID,参_内存地址)
FLOAT ReadProcessFloat(DWORD dwPid, vint lpBase);  // -------------------------👉 内存_读小数 👈 -------------------------

//@返回   成功返回双浮点数据,失败返回-1
//@别名   内存_读双精度小数(参_进程ID,参_内存地址)
DOUBLE ReadProcessDoubleFloat(DWORD dwPid, vint lpBase);  // -------------------------👉 内存_读双精度小数 👈 -------------------------

//@返回   成功返回长整型数据,失败返回-1
//@别名   内存_读长整数(参_进程ID,参_内存地址)
INT64 ReadProcessLong(DWORD dwPid, vint lpBase);  // -------------------------👉 内存_读长整数 👈 -------------------------

//@返回   成功返回变整型数据,失败返回-1
//@别名   内存_读变整数(参_进程ID,参_内存地址)
vint ReadProcessIntP(DWORD dwPid, vint lpBase);  // -------------------------👉 内存_读变整数 👈 -------------------------

//@备注   读取长度留空 为智能读取
//@返回   成功返回文本型W(双字节字符串)数据,读UNICODE文本,失败返回空文本
//@别名   内存_读文本W(参_进程ID,参_内存地址,参_读取长度)
CXText ReadProcessText(DWORD dwPid, vint lpBase, vint lpLen = 0);  // -------------------------👉 内存_读文本W 👈 -------------------------

//@备注   读取长度留空 为智能读取
//@返回   成功返回文本型A(单字节字符串)数据,读ANSI GBK GB2312编码,失败返回空文本
//@别名   内存_读文本A(参_进程ID,参_内存地址,参_读取长度)
CXTextA ReadProcessTextA(DWORD dwPid, vint lpBase, vint lpLen = 0);   // -------------------------👉 内存_读文本A 👈 -------------------------

//@备注   读取字节集数据
//@返回   成功返回字节集数据
//@参数   进程ID
//@参数   内存地址
//@参数   留空自动读取长度
//@别名   内存_读字节集(参_进程ID,参_内存地址,参_长度)
CXBytes ReadProcessBin(DWORD dwPid, vint lpBase, vint lpLen = 0);  // -------------------------👉 内存_读字节集 👈 -------------------------

//@返回   成功返回字节数据
//@参数   -1默认取自身进程
//@别名   内存_读字节2(参_进程句柄,参_内存地址)
BYTE ReadProcessByte2(vint hProcess, vint lpBase);  // -------------------------👉 内存_读字节2 👈 -------------------------

//@返回   成功返回短整型数据
//@参数   -1默认取自身进程
//@别名   内存_读短整数2(参_进程句柄,参_内存地址)
SHORT ReadProcessShort2(vint hProcess, vint lpBase);  // -------------------------👉 内存_读短整数2 👈 -------------------------

//@返回   成功返回整型数据
//@参数   -1默认取自身进程
//@别名   内存_读整数2(参_进程句柄,参_内存地址)
INT ReadProcessInt2(vint hProcess, vint lpBase);  // -------------------------👉 内存_读整数2 👈 -------------------------

//@返回   成功返回单浮点数据
//@参数   -1默认取自身进程
//@别名   内存_读小数2(参_进程句柄,参_内存地址)
FLOAT ReadProcessFloat2(vint hProcess, vint lpBase);   // -------------------------👉 内存_读小数2 👈 -------------------------

//@返回   成功返回双浮点数据
//@参数   -1默认取自身进程
//@别名   内存_读双精度小数2(参_进程句柄,参_内存地址)
DOUBLE ReadProcessDoubleFloat2(vint hProcess, vint lpBase);  // -------------------------👉 内存_读双精度小数2 👈 -------------------------

//@返回   成功返回长整型数据
//@参数   -1默认取自身进程
//@别名   内存_读长整数2(参_进程句柄,参_内存地址)
INT64 ReadProcessLong2(vint hProcess, vint lpBase);  // -------------------------👉 内存_读长整数2 👈 -------------------------

//@返回   成功返回变整型数据
//@参数   -1默认取自身进程
//@别名   内存_读变整数2(参_进程句柄,参_内存地址)
vint ReadProcessIntP2(vint hProcess, vint lpBase);  // -------------------------👉 内存_读变整数2 👈 -------------------------

//@返回   成功返回文本型W(双字节字符串)数据
//@参数   -1默认取自身进程
//@参数    内存地址
//@参数    留空自动读取长度
//@别名   内存_读文本W2(参_进程句柄,参_内存地址,参_读取长度)
CXText ReadProcessText2(vint hProcess, vint lpBase, vint dwLen = 0);  // -------------------------👉 内存_读文本W2 👈 -------------------------

//@返回   成功返回文本型A(单字节字符串)数据   ANSI GBK GB2312编码
//@参数   -1默认取自身进程
//@参数    内存地址
//@参数    0默认自动读取
//@别名   内存_读文本A2(参_进程句柄,参_内存地址,参_读取长度)
CXTextA ReadProcessTextA2(vint hProcess, vint lpBase, vint dwLen = 0);  // -------------------------👉 内存_读文本A2 👈 -------------------------

//@备注   读取字节集数据
//@返回   成功返回字节集数据
//@参数   -1默认取自身进程
//@参数   内存地址
//@参数   留空自动读取长度
//@别名   内存_读字节集2(参_进程句柄,参_内存地址,参_长度)
CXBytes ReadProcessBin2(vint hProcess, vint lpBase, SIZE_T dwLen = 0);  // -------------------------👉 内存_读字节集2 👈 -------------------------

//@参数   -1默认取自身进程
//@参数   比如“0A1574D+1D45+547” 或 "[PlantsVsZombies.exe+2A9EC0]+768+5560"
//@别名   内存_读代码_整数(参_进程ID,参_基址表达式)
DWORD ReadExpressionInt(DWORD dwPid, CXText wExpression);  // -------------------------👉 内存_读代码_整数 👈 -------------------------

//@参数   -1默认取自身进程
//@参数   比如“0A1574D+1D45+547” 或 "[PlantsVsZombies.exe+2A9EC0]+768+5560"
//@别名   内存_读代码_小数(参_进程ID,参_基址表达式)
FLOAT ReadExpressionFloat(DWORD dwPid, CXText wExpression);   // -------------------------👉 内存_读代码_小数 👈 -------------------------

//@参数   -1默认取自身进程
//@参数   比如“0A1574D+1D45+547” 或 "[PlantsVsZombies.exe+2A9EC0]+768+5560"
//@别名   内存_读代码_双精度小数(参_进程ID,参_基址表达式)
DOUBLE ReadExpressionDoubleFloat(DWORD dwPid, CXText wExpression);  // -------------------------👉 内存_读代码_双精度小数 👈 -------------------------

//@参数   -1默认取自身进程
//@参数   比如“0A1574D+1D45+547” 或 "[PlantsVsZombies.exe+2A9EC0]+768+5560"
//@别名   内存_读代码_长整数(参_进程ID,参_基址表达式)
INT64 ReadExpressionLong(DWORD dwPid, CXText wExpression);  // -------------------------👉 内存_读代码_长整数 👈 -------------------------

//@参数   -1默认取自身进程
//@参数   比如“0A1574D+1D45+547” 或 "[PlantsVsZombies.exe+2A9EC0]+768+5560"
//@别名   内存_读代码_变整数(参_进程ID,参_基址表达式)
vint ReadExpressionIntP(DWORD dwPid, CXText wExpression);  // -------------------------👉 内存_读代码_变整数 👈 -------------------------

//@参数   -1默认取自身进程
//@参数   比如“0A1574D+1D45+547” 或 "[PlantsVsZombies.exe+2A9EC0]+768+5560"
//@别名   内存_读代码_文本型(参_进程ID,参_基址表达式)
CXText ReadExpressionText(DWORD dwPid, CXText wExpression);  // -------------------------👉 内存_读代码_文本型 👈 -------------------------

//@参数   -1默认取自身进程
//@参数   比如“0A1574D+1D45+547” 或 "[PlantsVsZombies.exe+2A9EC0]+768+5560"
//@别名   内存_读代码_文本A(参_进程ID,参_基址表达式)
CXTextA ReadExpressionTextA(DWORD dwPid, CXText wExpression);  // -------------------------👉 内存_读代码_文本A 👈 -------------------------

//@参数   -1默认取自身进程
//@参数   比如“0A1574D+1D45+547” 或 "[PlantsVsZombies.exe+2A9EC0]+768+5560"
//@别名   内存_读代码_字节集(参_进程ID,参_基址表达式)
CXBytes ReadExpressionBin(DWORD dwPid, CXText wExpression);  // -------------------------👉 内存_读代码_字节集 👈 -------------------------

//@参数   -1默认取自身进程
//@参数   比如“0A1574D+1D45+547” 或 "[PlantsVsZombies.exe+2A9EC0]+768+5560"
//@别名   内存_读代码_整数2(参_进程句柄,参_基址表达式)
DWORD ReadExpressionInt2(vint hProcess, CXText wExpression);  // -------------------------👉 内存_读代码_整数2 👈 -------------------------

//@参数   -1默认取自身进程
//@参数   比如“0A1574D+1D45+547” 或 "[PlantsVsZombies.exe+2A9EC0]+768+5560"
//@别名   内存_读代码_小数2(参_进程句柄,参_基址表达式)
FLOAT ReadExpressionFloat2(vint hProcess, CXText wExpression);  // -------------------------👉 内存_读代码_小数2 👈 -------------------------

//@参数   -1默认取自身进程
//@参数   比如“0A1574D+1D45+547” 或 "[PlantsVsZombies.exe+2A9EC0]+768+5560"
//@别名   内存_读代码_双精度小数2(参_进程句柄,参_基址表达式)
DOUBLE ReadExpressionDoubleFloat2(vint hProcess, CXText wExpression);  // -------------------------👉 内存_读代码_双精度小数2 👈 -------------------------

//@参数   -1默认取自身进程
//@参数   比如“0A1574D+1D45+547” 或 "[PlantsVsZombies.exe+2A9EC0]+768+5560"
//@别名   内存_读代码_长整数2(参_进程句柄,参_基址表达式)
INT64 ReadExpressionLong2(vint hProcess, CXText wExpression);  // -------------------------👉 内存_读代码_长整数2 👈 -------------------------

//@参数   -1默认取自身进程
//@参数   比如“0A1574D+1D45+547” 或 "[PlantsVsZombies.exe+2A9EC0]+768+5560"
//@别名   内存_读代码_变整数2(参_进程句柄,参_基址表达式)
vint ReadExpressionIntP2(vint hProcess, CXText wExpression);  // -------------------------👉 内存_读代码_变整数2 👈 -------------------------

//@参数   -1默认取自身进程
//@参数   比如“0A1574D+1D45+547” 或 "[PlantsVsZombies.exe+2A9EC0]+768+5560"
//@别名   内存_读代码_文本型2(参_进程句柄,参_基址表达式)
CXText ReadExpressionText2(vint hProcess, CXText wExpression);  // -------------------------👉 内存_读代码_文本型2 👈 -------------------------

//@参数   -1默认取自身进程
//@参数   比如“0A1574D+1D45+547” 或 "[PlantsVsZombies.exe+2A9EC0]+768+5560"
//@别名   内存_读代码_文本A2(参_进程句柄,参_基址表达式)
CXTextA ReadExpressionTextA2(vint hProcess, CXText wExpression);  // -------------------------👉 内存_读代码_文本A2 👈 -------------------------

//@参数   -1默认取自身进程
//@参数   比如“0A1574D+1D45+547” 或 "[PlantsVsZombies.exe+2A9EC0]+768+5560"
//@别名   内存_读代码_字节集2(参_进程句柄,参_基址表达式)
CXBytes ReadExpressionBin2(vint hProcess, CXText wExpression);  // -------------------------👉 内存_读代码_字节集2 👈 -------------------------

//@备注   例如 xxx.exe+0x4566 这种形式 直接返回对应基址
//@返回   成功返回内存地址
//@参数   -1默认取自身进程
//@别名   内存_读基址(参_进程ID,参_基址表达式)
vint ReadModuleBase(DWORD dwPid, CXText wExpression);  // -------------------------👉 内存_读基址 👈 -------------------------

//@备注   例如 xxx.exe+0x4566 这种形式 直接返回对应基址
//@返回   成功返回内存地址
//@参数   -1默认取自身进程
//@别名   内存_读基址2(参_进程句柄,参_基址表达式)
vint ReadModuleBase2(vint hProcess, CXText wExpression);  // -------------------------👉 内存_读基址2 👈 -------------------------

//@备注   写字节数据
//@返回   成功返回真,失败返回假
//@参数   -1默认取自身进程
//@参数   内存地址
//@参数   写入的数据
//@别名   内存_写字节(参_进程ID,参_内存地址,参_写入的数据)
BOOL WriteProcessByte(DWORD dwPid, vint lpBase, BYTE lData);  // -------------------------👉 内存_写字节 👈 -------------------------

//@备注   写短整数数据
//@返回   成功返回真,失败返回假
//@参数   -1默认取自身进程
//@参数   内存地址
//@参数   写入的数据
//@别名   内存_写短整数(参_进程ID,参_内存地址,参_写入的数据)
BOOL WriteProcessShort(DWORD dwPid, vint lpBase, SHORT lData);  // -------------------------👉 内存_写短整数 👈 -------------------------

//@备注   写整数数据
//@返回   成功返回真,失败返回假
//@参数   -1默认取自身进程
//@参数   内存地址
//@参数   写入的数据
//@别名   内存_写整数(参_进程ID,参_内存地址,参_写入的数据)
BOOL WriteProcessInt(DWORD dwPid, vint lpBase, DWORD lData);  // -------------------------👉 内存_写整数 👈 -------------------------

//@备注   写长整数数据
//@返回   成功返回真,失败返回假
//@参数   -1默认取自身进程
//@参数   内存地址
//@参数   写入的数据
//@别名   内存_写长整数(参_进程ID,参_内存地址,参_写入的数据)
BOOL WriteProcessLong(DWORD dwPid, vint lpBase, INT64 lData);  // -------------------------👉 内存_写长整数 👈 -------------------------

//@备注   写变整数数据
//@返回   成功返回真,失败返回假
//@参数   -1默认取自身进程
//@参数   内存地址
//@参数   写入的数据
//@别名  内存_写变整数(参_进程ID,参_内存地址,参_写入的数据)
BOOL WriteProcessIntP(DWORD dwPid, vint lpBase, vint intpData);  // -------------------------👉 内存_写变整数 👈 -------------------------

//@备注   写小数数据
//@返回   成功返回真,失败返回假
//@参数   -1默认取自身进程
//@参数   内存地址
//@参数   写入的数据
//@别名   内存_写小数(参_进程ID,参_内存地址,参_写入的数据)
BOOL WriteProcessFloat(DWORD dwPid, vint lpBase, FLOAT intpData);  // -------------------------👉 内存_写小数 👈 -------------------------

//@备注   写双精度小数数据
//@返回   成功返回真,失败返回假
//@参数   -1默认取自身进程
//@参数   内存地址
//@参数   写入的数据
//@别名   内存_写双精度小数(参_进程ID,参_内存地址,参_写入的数据)
BOOL WriteProcessDoublieFloat(DWORD dwPid, vint lpBase, DOUBLE intpData);  // -------------------------👉 内存_写双精度小数 👈 -------------------------

//@备注   写宽文本数据
//@返回   成功返回真,失败返回假
//@参数   -1默认取自身进程
//@参数   内存地址
//@参数   写入的数据
//@别名   内存_写文本(参_进程ID,参_内存地址,参_写入的数据)
BOOL WriteProcessText(DWORD dwPid, vint lpBase, CXText wData);  // -------------------------👉 内存_写文本 👈 -------------------------

//@备注   把当前进程的指针数据,写入到目标 进程中
//@返回   成功返回真,失败返回假
//@参数   -1默认取自身进程
//@参数   内存地址
//@参数   写入的数据
//@别名   内存_写指针数据(参_进程ID,参_内存地址,参_写入的数据指针,参_写入长度)
BOOL WriteProcessPtrData(DWORD dwPid, vint lpBase, vint bData, DWORD iLen);  // -------------------------👉 内存_写指针数据 👈 -------------------------

//@备注   写字节集数据
//@返回   成功返回真 失败返回假
//@参数   -1默认取自身进程
//@参数   内存地址
//@参数   写入的字节集数据
//@参数   留空自动读取长度
//@别名   内存_写字节集(参_进程ID,参_内存地址,参_写入的数据,参_写入长度)
BOOL WriteProcessBin(DWORD dwPid, vint lpBase, CXBytes bData, DWORD iLen);  // -------------------------👉 内存_写字节集 👈 -------------------------

//@备注   写文本数据,ANSI GBK GB2312编码
//@返回   成功返回真,失败返回假
//@参数   -1默认取自身进程
//@参数   内存地址
//@参数   写入的数据
//@别名   内存_写文本A(参_进程ID,参_内存地址,参_写入的数据)
BOOL WriteProcessTextA(DWORD dwPid, vint lpBase, CXTextA wData);  // -------------------------👉 内存_写文本A 👈 -------------------------

//@备注   写字节数据
//@返回   成功返回真,失败返回假
//@参数   -1默认取自身进程
//@参数   内存地址
//@参数   写入的数据
//@别名   内存_写字节2(参_进程句柄,参_内存地址,参_写入的数据)
BOOL WriteProcessByte2(vint hProcess, vint lpBase, BYTE lData);  // -------------------------👉 内存_写字节2 👈 -------------------------

//@备注   写短整数数据
//@返回   成功返回真,失败返回假
//@参数   -1默认取自身进程
//@参数   内存地址
//@参数   写入的数据
//@别名   内存_写短整数2(参_进程句柄,参_内存地址,参_写入的数据)
BOOL WriteProcessShort2(vint hProcess, vint lpBase, SHORT lData);  // -------------------------👉 内存_写短整数2 👈 -------------------------

//@备注   写整数数据
//@返回   成功返回真,失败返回假
//@参数   -1默认取自身进程
//@参数   内存地址
//@参数   写入的数据
//@别名   内存_写整数2(参_进程句柄,参_内存地址,参_写入的数据)
BOOL WriteProcessInt2(vint hProcess, vint lpBase, DWORD lData);  // -------------------------👉 内存_写整数2 👈 -------------------------

//@备注   写小数数据
//@返回   成功返回真,失败返回假
//@参数   -1默认取自身进程
//@参数   内存地址
//@参数   写入的数据
//@别名   内存_写小数2(参_进程句柄,参_内存地址,参_写入的数据)
BOOL WriteProcessFloat2(vint hProcess, vint lpBase, FLOAT lData);  // -------------------------👉 内存_写小数2 👈 -------------------------

//@备注   写双精度小数数据
//@返回   成功返回真,失败返回假
//@参数   -1默认取自身进程
//@参数   内存地址
//@参数   写入的数据
//@别名   内存_写双精度小数2(参_进程句柄,参_内存地址,参_写入的数据)
BOOL WriteProcessDoublieFloat2(vint hProcess, vint lpBase, DOUBLE lData);  // -------------------------👉 内存_写双精度小数2 👈 -------------------------

//@备注   写长整数数据
//@返回   成功返回真,失败返回假
//@参数   -1默认取自身进程
//@参数   内存地址
//@参数   写入的数据
//@别名   内存_写长整数2(参_进程句柄,参_内存地址,参_写入的数据)
BOOL WriteProcessLong2(vint hProcess, vint lpBase, INT64 lData);  // -------------------------👉 内存_写长整数2 👈 -------------------------

//@备注   写变整数数据
//@返回   成功返回真,失败返回假
//@参数   -1默认取自身进程
//@参数   内存地址
//@参数   写入的数据
//@别名  内存_写变整数2(参_进程句柄,参_内存地址,参_写入的数据)
BOOL WriteProcessIntP2(vint hProcess, vint lpBase, vint lData);  // -------------------------👉 内存_写变整数2 👈 -------------------------

//@备注   写宽文本数据
//@返回   成功返回真,失败返回假
//@参数   -1默认取自身进程
//@参数   内存地址
//@参数   写入的数据
//@别名   内存_写文本2(参_进程句柄,参_内存地址,参_写入的数据)
BOOL WriteProcessText2(vint hProcess, vint lpBase, CXText lData);  // -------------------------👉 内存_写文本2 👈 -------------------------

//@备注   写文本数据,ANSI GBK GB2312编码
//@返回   成功返回真,失败返回假
//@参数   -1默认取自身进程
//@参数   内存地址
//@参数   写入的数据
//@别名   内存_写文本A2(参_进程句柄,参_内存地址,参_写入的数据)
BOOL WriteProcessTextA2(vint hProcess, vint lpBase, CXTextA lData);  // -------------------------👉 内存_写文本A2 👈 -------------------------

//@备注   把当前进程的指针数据,写入到目标 进程中
//@返回   成功返回真,失败返回假
//@参数   -1默认取自身进程
//@参数   内存地址
//@参数   写入的数据
//@别名   内存_写指针数据2(参_进程句柄,参_内存地址,参_写入的数据指针,参_写入长度)
BOOL WriteProcessPtrData2(vint hProcess, vint lpBase, vint lpData, DWORD iLen = 0);  // -------------------------👉 内存_写指针数据2 👈 -------------------------

//@备注   写字节集数据
//@返回   成功返回真 失败返回假
//@参数   -1默认取自身进程
//@参数   内存地址
//@参数   写入的字节集数据
//@参数   留空自动读取长度
//@别名   内存_写字节集2(参_进程句柄,参_内存地址,参_写入的数据,参_写入长度)
BOOL WriteProcessBin2(vint hProcess, vint lpBase, CXBytes bData, DWORD iLen = 0);  // -------------------------👉 内存_写字节集2 👈 -------------------------

//@备注   指定进程申请一段为00的内存
//@返回   成功返回申请的内存地址
//@参数   -1默认取自身进程
//@别名   内存_申请(参_进程ID,参_长度)
vint AllocProcessMemory(DWORD dwPid = -1, vint dwLen = 32);  // -------------------------👉 内存_申请 👈 -------------------------

//@备注   指定进程申请一段为00的内存
//@返回   成功返回申请的内存地址
//@参数   -1默认取自身进程
//@别名   内存_申请2(参_进程句柄,参_长度)
vint AllocProcessMemory2(vint hProcess = -1, vint dwLen = 32);  // -------------------------👉 内存_申请2 👈 -------------------------

//@备注   指定进程申请一段为00的内存
//@返回   成功返回申请的内存地址
//@参数   -1默认取自身进程
//@参数   写入申请内存中的字节集数据
//@别名   内存_申请字节集(参_进程ID,参_字节集数据)
vint AllocProcessBinMemory(DWORD dwPid, CXBytes bData);  // -------------------------👉 内存_申请字节集 👈 -------------------------

//@备注   指定进程申请一段为00的内存
//@返回   成功返回申请的内存地址
//@参数   -1默认取自身进程
//@参数   写入申请内存中的字节集数据
//@别名   内存_申请字节集2(参_进程句柄,参_字节集数据)
vint AllocProcessBinMemory2(vint hProcess, CXBytes bData);  // -------------------------👉 内存_申请字节集2 👈 -------------------------

//@备注   指定进程申请一段为00的内存
//@返回   成功返回申请的内存地址
//@参数   -1默认取自身进程
//@参数   参考地址
//@别名   内存_申请附近(参_进程ID,参_参考地址,参_长度)
vint AllocProcessNearMemory(DWORD dwPid, vint lpStartBase, vint dwLen = 32);   // -------------------------👉 内存_申请附近 👈 -------------------------

//@备注   指定进程申请一段为00的内存
//@返回   成功返回申请的内存地址
//@参数   -1默认取自身进程
//@参数   参考地址
//@别名   内存_申请附近2(参_进程句柄,参_参考地址,参_长度)
vint AllocProcessNearMemory2(vint hProcess, vint lpStartBase, vint dwLen = 32);   // -------------------------👉 内存_申请附近2 👈 -------------------------

//@备注   指定进程申请一段为00的内存
//@返回   成功返回申请的内存地址
//@参数   -1默认取自身进程
//@参数   参考地址
//@别名   内存_申请高位(参_进程ID,参_长度)
vint AllocProcessHighMemory(DWORD dwPid, vint lpLen = 32);  // -------------------------👉 内存_申请高位 👈 -------------------------

//@备注   指定进程申请一段为00的内存
//@返回   成功返回申请的内存地址
//@参数   -1默认取自身进程
//@参数   参考地址
//@别名   内存_申请高位2(参_进程句柄,参_长度)
vint AllocProcessHighMemory2(vint hProcess = -1, vint lpLen = 4096);  // -------------------------👉 内存_申请高位2 👈 -------------------------

//@备注   释放指定内存
//@返回   成功返回真,失败返回假
//@参数   -1默认取自身进程
//@参数   内存地址
//@参数   留空自动读取长度
//@别名   内存_释放(参_进程ID,参_内存地址)
BOOL FreeProcessMemory(DWORD dwPid, vint lpBase);  // -------------------------👉 内存_释放 👈 -------------------------

//@备注   释放指定内存
//@返回   成功返回真,失败返回假
//@参数   -1默认取自身进程
//@参数   内存地址
//@参数   留空自动读取长度
//@别名   内存_释放2(参_进程句柄,参_内存地址)
BOOL FreeProcessMemory2(vint hProcess, vint lpBase);  // -------------------------👉 内存_释放2 👈 -------------------------

//@备注   SetProcessWorkingSetSize
//@返回   成功返回真,失败返回假
//@参数   -1默认取自身进程
//@别名   内存_优化(参_进程ID)
BOOL OptimizMemory(DWORD dwPid);  // -------------------------👉 内存_优化 👈 -------------------------

//@备注   SetProcessWorkingSetSize
//@返回   成功返回真,失败返回假
//@参数   -1默认取自身进程
//@别名   内存_优化2(参_进程句柄)
BOOL OptimizMemory2(vint hProcess);  // -------------------------👉 内存_优化2 👈 -------------------------

//@备注   读取整个模块的内存
//@返回   成功返回模块字节集数据
//@参数   -1默认取自身进程
//@参数   模块名称，如 version.dll
//@别名   内存_读模块内存(参_进程ID,参_模块名)
CXBytes ReadProcessMoudle(DWORD dwPid, CXText szModuleName);  // -------------------------👉 内存_读模块内存 👈 -------------------------

//@备注   读取整个模块的内存
//@返回   成功返回模块字节集数据
//@参数   -1默认取自身进程
//@参数   模块名称，如 version.dll
//@别名   内存_读模块内存2(参_进程句柄,参_模块名)
CXBytes ReadProcessMoudle2(vint hProcess, CXText szModuleName);  // -------------------------👉 内存_读模块内存2 👈 -------------------------

//@备注   对内存进行搜索,速度比较慢;  注意, 本命令会过滤部分权限, 请使用CE搜索进行对比.
//@返回   成功返回搜索到的结果数量,失败返回0
//@参数   -1默认取自身进程
//@参数   要搜索的数据,其他类型自行转换字节集类
//@参数   接收搜索结果的地址数组
//@参数   开始的地址，默认为0x400000
//@参数   结束的地址，64位默认00007fffffffffff, 32位默认0x7FFFFFFF
//@别名   内存_搜索(参_进程ID,参_搜索的数据,参_地址数组,参_起始地址,参_结束地址)
DWORD SearchProcessMemory(DWORD dwPid, CXBytes bData, CXVector<vint>& lpArr, vint lpStar = 0x400000, vint lpEnd = 0);  // -------------------------👉 内存_搜索 👈 -------------------------

//@备注   对内存进行搜索,速度比较慢;  注意, 本命令会过滤部分权限, 请使用CE搜索进行对比.
//@返回   成功返回搜索到的结果数量,失败返回0
//@参数   -1默认取自身进程
//@参数   要搜索的数据,其他类型自行转换字节集类
//@参数   接收搜索结果的地址数组
//@参数   开始的地址，默认为0x400000
//@参数   结束的地址，64位默认00007fffffffffff, 32位默认0x7FFFFFFF
//@别名   内存_搜索2(参_进程句柄,参_搜索的数据,参_地址数组,参_起始地址,参_结束地址)
DWORD SearchProcessMemory2(vint hProcess, CXBytes bData, CXVector<vint>& lpArr, vint lpStar = 0x400000, vint lpEnd = 0);  // -------------------------👉 内存_搜索2 👈 -------------------------

//@备注   对进程内存进行模糊搜索,速度比较慢;  注意, 本命令会过滤部分权限, 请使用CE搜索进行对比.
//@返回   成功返回搜索到的结果数量,失败返回0
//@参数   -1默认取自身进程
//@参数   带*或?号代替如"FF**AA??02"16进制, 2个字符为1个字节，1必须写成01，长度不要超过整数型
//@参数   接收搜索结果的地址数组
//@参数   开始的地址，默认为0x400000
//@参数   结束的地址，64位默认00007fffffffffff, 32位默认0x7FFFFFFF
//@别名   内存_搜索Ex(参_进程ID,参_搜索的数据,参_地址数组,参_起始地址,参_结束地址)
DWORD SearchProcessMemoryEx(DWORD dwPid, CXText bData, CXVector<vint>& lpArr, vint lpStar = 0x400000, vint lpEnd = 0);   // -------------------------👉 内存_搜索Ex 👈 -------------------------

//@备注   对进程内存进行模糊搜索,速度比较慢;  注意, 本命令会过滤部分权限, 请使用CE搜索进行对比.
//@返回   成功返回搜索到的结果数量,失败返回0
//@参数   -1默认取自身进程
//@参数   带*或?号代替如"FF**AA??02"16进制, 2个字符为1个字节，1必须写成01，长度不要超过整数型
//@参数   接收搜索结果的地址数组
//@参数   开始的地址，默认为0x400000
//@参数   结束的地址，64位默认00007fffffffffff, 32位默认0x7FFFFFFF
//@别名   内存_搜索Ex2(参_进程句柄,参_搜索的数据,参_地址数组,参_起始地址,参_结束地址)
DWORD SearchProcessMemoryEx2(vint hProcess, CXText bData, CXVector<vint>& lpArr, vint lpStar = 0x400000, vint lpEnd = 0);   // -------------------------👉 内存_搜索Ex2 👈 -------------------------

//@备注   对进程模块内存进行模糊搜索,速度特快
//@返回   成功返回搜索到的结果数量,失败返回0
//@参数   -1默认取自身进程
//@参数   带*或?号代替如"FF**AA??02"16进制, 2个字符为1个字节，1必须写成01，长度不要超过整数型
//@参数   欲搜索内存的指定模块名称
//@参数   接收搜索结果的地址数组
//@别名   内存_搜索_模块(参_进程ID,参_搜索的数据,参_模块名,参_地址数组)
DWORD SearchProcessMemorMoudle(DWORD dwPid, CXText bData, CXText wName, CXVector<vint>& lpArr);  // -------------------------👉 内存_搜索_模块 👈 -------------------------

//@备注   对进程模块内存进行模糊搜索,速度特快
//@返回   成功返回搜索到的结果数量,失败返回0
//@参数   -1默认取自身进程
//@参数   带*或?号代替如"FF**AA??02"16进制, 2个字符为1个字节，1必须写成01，长度不要超过整数型
//@参数   欲搜索内存的指定模块名称
//@参数   接收搜索结果的地址数组
//@别名   内存_搜索_模块2(参_进程句柄,参_搜索的数据,参_模块名,参_地址数组)
DWORD SearchProcessMemorMoudle2(vint hProcess, CXText bData, CXText wName, CXVector<vint>& lpArr);  // -------------------------👉 内存_搜索_模块2 👈 -------------------------

//@分组} XM_内存操作
//=========================👆 👆 👆 👆 XM_内存读写 👆 👆 👆 👆====================================



//Sunday算法实现内存快速搜索特征码(支持通配符模糊搜索)
//=========================👇 👇 👇 👇 XM_特征码 👇 👇 👇 👇====================================
//@分组{ XM_特征码

//@备注   特征码搜索,返回第一个结果
//@返回   成功返回搜索到的第一个结果
//@参数   -1默认取自身进程
//@参数   十六进制文本,首尾无空格,中间空格不可省略,支持通配符 ?  例如"BA ?? 00 B4 09 ?? 21"
//@参数   开始的地址，默认为0x400000
//@参数   结束的地址，64位默认00007fffffffffff, 32位默认0x7FFFFFFF
//@别名   特征码_搜索(参_进程ID,参_搜索的数据,参_起始地址,参_结束地址)
vint FindCodeAddr(DWORD dwPid, CXText bData, vint lpStar = 0x400000, vint lpEnd = 0);  // -------------------------👉 特征码_搜索 👈 -------------------------

//@备注   快速搜索特征码,返回数组结果
//@返回   成功返回搜索到的结果数量,失败返回0
//@参数   -1默认取自身进程
//@参数   十六进制文本,首尾无空格,中间空格不可省略,支持通配符 ?  例如"BA ?? 00 B4 09 ?? 21"
//@参数   接收搜索结果的地址数组
//@参数   开始的地址，默认为0x400000
//@参数   结束的地址，64位默认00007fffffffffff, 32位默认0x7FFFFFFF
//@别名   特征码_搜索_数组(参_进程ID,参_搜索的数据,参_地址数组,参_起始地址,参_结束地址)
DWORD FindCodeArr(DWORD dwPid, CXText bData, CXVector<vint>& lpArr, vint lpStar = 0x400000, vint lpEnd = 0);  // -------------------------👉 特征码_搜索_数组 👈 -------------------------

//@备注   快速在模块内搜索特征码,返回数组结果
//@返回   成功返回搜索到的结果数量,失败返回0
//@参数   -1默认取自身进程
//@参数   模块名称, 如 version.dll
//@参数   十六进制文本,首尾无空格,中间空格不可省略,支持通配符 ?  例如"BA ?? 00 B4 09 ?? 21"
//@参数   接收搜索结果的地址数组
//@别名   特征码_搜索_模块(参_进程ID,参_模块名,参_搜索的数据,参_地址数组)
DWORD FindModCodeArr(DWORD dwPid, CXText wName, CXText  bData, CXVector<vint>& lpArr);  // -------------------------👉 特征码_搜索_模块 👈 -------------------------

//@备注   特征码搜索,返回第一个结果
//@返回   成功返回搜索到的第一个结果
//@参数   -1默认取自身进程
//@参数   十六进制文本,首尾无空格,中间空格不可省略,支持通配符 ?  例如"BA ?? 00 B4 09 ?? 21"
//@参数   开始的地址，默认为0x400000
//@参数   结束的地址，64位默认00007fffffffffff, 32位默认0x7FFFFFFF
//@别名   特征码_搜索2(参_进程句柄,参_搜索的数据,参_起始地址,参_结束地址)
vint FindCodeAddr2(vint hProcess, CXText bData, vint lpStar = 0x400000, vint lpEnd = 0);  // -------------------------👉 特征码_搜索2 👈 -------------------------

//@备注   快速搜索特征码,返回数组结果
//@返回   成功返回搜索到的结果数量,失败返回0
//@参数   -1默认取自身进程
//@参数   十六进制文本,首尾无空格,中间空格不可省略,支持通配符 ?  例如"BA ?? 00 B4 09 ?? 21"
//@参数   接收搜索结果的地址数组
//@参数   开始的地址，默认为0x400000
//@参数   结束的地址，64位默认00007fffffffffff, 32位默认0x7FFFFFFF
//@别名   特征码_搜索_数组2(参_进程句柄,参_搜索的数据,参_地址数组,参_起始地址,参_结束地址)
DWORD FindCodeArr2(vint hProcess, CXText bData, CXVector<vint>& lpArr, vint lpStar = 0x400000, vint lpEnd = 0);  // -------------------------👉 特征码_搜索_数组2 👈 -------------------------

//@备注   快速在模块内搜索特征码,返回数组结果
//@返回   成功返回搜索到的结果数量,失败返回0
//@参数   -1默认取自身进程
//@参数   模块名称, 如 version.dll
//@参数   十六进制文本,首尾无空格,中间空格不可省略,支持通配符 ?  例如"BA ?? 00 B4 09 ?? 21"
//@参数   接收搜索结果的地址数组
//@别名   特征码_搜索_模块2(参_进程句柄,参_模块名,参_搜索的数据,参_地址数组)
DWORD FindModCodeArr2(vint hProcess, CXText wName, CXText  bData, CXVector<vint>& lpArr);  // -------------------------👉 特征码_搜索_模块2 👈 -------------------------

//@分组} XM_特征码
//=========================👆 👆 👆 👆 XM_特征码 👆 👆 👆 👆====================================









//=========================👇 👇 👇 👇 XM_网页访问 👇 👇 👇 👇====================================
//@分组{ XM_网页访问

//@备注   返回更新后的Cookie
//@参数   旧Cookie
//@参数   新Cookie
//@别名   网页_Cookie合并更新(旧Cookie,新Cookie)
CXText UpDataCookies(CXText oldCookies, CXText newCookies);   // ------------------------->>> 网页_Cookie合并更新 <<<-------------------------

//@参数   参_文本数组
//@参数   参_成员
//@别名   Cookies是否存在(参_文本数组,参_成员)
BOOL IsCookieExist(CXVector<CXText> cookiesArr, CXText cookieName);   // ------------------------->>> Cookies是否存在 <<<-------------------------

//@备注   附加协议头处添加即可
//@参数   指定伪装的IP
//@别名   网页_伪装IP(参_IP)
CXText FakeIp(CXText 参_IP = L"");   // ------------------------->>> 网页_伪装IP <<< -------------------------

//@备注   类似于HTTP读文件
//@返回   返回BYTE$集数据
//@参数   欲取网络文件地址
//@别名   网页_读文件(参_网址)
CXBytes ReadWebFile(CXText wUrl);   // ------------------------->>> 网页_读文件 <<<-------------------------

//@分组} XM_网页访问
//=========================👆 👆 👆 👆 XM_网页访问 👆 👆 👆 👆====================================







//=========================👇 👇 👇 👇 XM_文本操作 👇 👇 👇 👇====================================
//@分组{ XM_文本操作

//@备注   从文本的左边按 欲寻找的文本 开始寻找
//@参数   被查找的文本
//@参数   欲寻找的文本
//@参数   起始寻找位置
//@参数   真.从右往左;假,从左往右;默认从左开始
//@参数   真.不区分,默认不区分;假.区分
//@别名   文本_取左边_XM(被查找的文本,欲寻找的文本,起始寻找位置,是否从右开始,是否不区分大小写)
CXText StrLeft(CXText wSourceStr, CXText wSearchStr, DWORD iStartPos = 0, BOOL bIsRight = FALSE, BOOL bIsCase = TRUE);  // -------------------------👉 文本_取左边_XM 👈 -------------------------

//@备注   从文本的左边按 欲寻找的文本 开始寻找
//@参数   被查找的文本
//@参数   欲寻找的文本
//@参数   起始寻找位置
//@参数   真.从左往右;假,从右往左;默认从右开始
//@参数   真.不区分,默认不区分;假.区分
//@别名   文本_取右边_XM(被查找的文本,欲寻找的文本,起始寻找位置,是否从左开始,是否不区分大小写)
CXText StrRight(CXText wSourceStr, CXText wSearchStr, DWORD iStartPos = 0, BOOL bIsLeft = FALSE, BOOL bIsCase = TRUE);  // -------------------------👉 文本_取右边_XM 👈 -------------------------

//@备注   取出中间文本
//@别名   文本_取中间_XM(欲取全文本,前面文本,后面文本,起始寻找位置,是否不区分大小写)
CXText StrMid(CXText wSourceStr, CXText wLeftStr, CXText wRightStr, DWORD iStartPos = 0, BOOL bIsCase = TRUE);  // -------------------------👉 文本_取中间_XM 👈 -------------------------

//@备注   从文本的右边按 欲寻找的文本 开始寻找
//@别名   文本_倒取中间_XM(欲取全文本,前面文本,后面文本,起始寻找位置,是否不区分大小写)
CXText StrRMid(CXText wSourceStr, CXText wLeftStr, CXText wRightStr, DWORD iStartPos = 0, BOOL bIsCase = TRUE);  // -------------------------👉 文本_倒取中间_XM 👈 -------------------------

//@备注   查找某段字或关键中在文本中的哪一行出现
//@返回   成功返回行数，失败返回0
//@参数   源文本
//@参数   欲查找的文本
//@参数   真.不区分,默认不区分;假.区分
//@别名   文本_取文本所在行(源文本,欲查找的文本,是否不区分大小写)
DWORD StrLine(CXText wSourceStr, CXText wSearchStr, BOOL bIsCase = TRUE);  // -------------------------👉 文本_取文本所在行 👈 -------------------------

//@备注   批量替换文本
//@别名   文本_替换()
CXText StrReplace(CXText 原文本, DWORD 替换进行的次数 = -1, DWORD 替换的起始位置 = 0, bool 是否不区分大小写 = TRUE, CXText 欲被替换的子文本1 = L"", CXText 用作替换的子文本1 = L"", CXText 欲被替换的子文本2 = L"", CXText 用作替换的子文本2 = L"", CXText 欲被替换的子文本3 = L"", CXText 用作替换的子文本3 = L"", CXText 欲被替换的子文本4 = L"", CXText 用作替换的子文本4 = L"", CXText 欲被替换的子文本5 = L"", CXText 用作替换的子文本5 = L"", CXText 欲被替换的子文本6 = L"", CXText 用作替换的子文本6 = L"", CXText 欲被替换的子文本7 = L"", CXText 用作替换的子文本7 = L"", CXText 欲被替换的子文本8 = L"", CXText 用作替换的子文本8 = L"", CXText 欲被替换的子文本9 = L"", CXText 用作替换的子文本9 = L"", CXText 欲被替换的子文本10 = L"", CXText 用作替换的子文本10 = L"", CXText 欲被替换的子文本11 = L"", CXText 用作替换的子文本11 = L"", CXText 欲被替换的子文本12 = L"", CXText 用作替换的子文本12 = L"", CXText 欲被替换的子文本13 = L"", CXText 用作替换的子文本13 = L"", CXText 欲被替换的子文本14 = L"", CXText 用作替换的子文本14 = L"", CXText 欲被替换的子文本15 = L"", CXText 用作替换的子文本15 = L"");   // ------------------------->>> 文本_替换<<< -------------------------

//@备注   把1格式化为01
//@参数   参_源文本
//@别名   文本_前补0(参_源文本)
CXText StrInsert(CXText 参_源文本);   // ------------------------->>> 文本_前补0 <<<-------------------------

//@备注   把字母转换到大写
//@参数   要转换的文本
//@别名   文本_到大写(要转换的文本)
CXText Str2Upper(CXText 要转换的文本);   // ------------------------->>> 文本_到大写 <<<-------------------------

//@参数   要转换的文本
//@别名   文本_删全部空(要转换的文本)
CXText StrTrimAll(CXText 要转换的文本);   // ------------------------->>> 文本_删全部空 <<<-------------------------

//@备注   删除一段文本前后的空格
//@参数   要转换的文本
//@别名   文本_删首尾空(要转换的文本)
CXText StrTrim(CXText 要转换的文本);   // ------------------------->>> 文本_删首尾空 <<<-------------------------

//@备注   判断指定文本是否是数字
//@参数   参_文本
//@别名   文本_是否为数字(参_文本)
BOOL StrIsNum(CXText 参_文本);   // ------------------------->>> 文本_是否为数字 <<<-------------------------

//@备注   向指定文本框后台发送文本
//@参数   参_编辑框句柄
//@参数   参_发送的内容
//@别名   文本_发送(参_编辑框句柄,参_发送的内容)
BOOL StrSend(vint 参_编辑框句柄, CXText 参_发送的内容);   // ------------------------->>> 文本_发送 <<<-------------------------

//@参数   参_编辑框句柄
//@参数   默认全选,FALSE为取消全选
//@别名   文本_全选(参_编辑框句柄,参_是否全选)
BOOL StrSelectAll(vint 参_编辑框句柄, BOOL 参_是否全选 = TRUE);   // ------------------------->>> 文本_全选 <<<-------------------------

//@参数   参_源文本
//@别名   文本_取长度(参_源文本)
DWORD StrLen(CXText 参_源文本);   // ------------------------->>> 文本_取长度 <<<-------------------------

//@备注   当指定文本长度不足时前面自动补零
//@参数   参_欲补齐文本
//@参数   参_补齐长度
//@别名   文本_自动补零(参_欲补齐文本,参_补齐长度)
CXText StrInsertAuto(CXText 参_欲补齐文本, DWORD 参_补齐长度);   // ------------------------->>> 文本_自动补零 <<<-------------------------

//@备注   例如 leybc 或 LEYBC 返回 Leybc
//@参数   不支持中文
//@别名   文本_首字母大写(参_英文文本)
CXText StrCapitalized(CXText 参_英文文本);   // ------------------------->>> 文本_首字母大写 <<<-------------------------

//@参数   参_待处理文本
//@参数   参_每行长度
//@参数   参_换行字符
//@别名   文本_分行(参_待处理文本,参_每行长度,参_换行字符)
CXText StrSplitLine(CXText 参_待处理文本, DWORD 参_每行长度 = 75, CXText 参_换行字符 = L"\n");   // ------------------------->>> 文本_分行 <<<-------------------------

//@备注   判断文本中的指定文本是否有重复
//@返回   有重复返回TRUE，没得复返回FALSE
//@参数   参_源文本
//@参数   参_查询的文本
//@别名   文本_是否重复(参_源文本,参_查询的文本)
BOOL IsStrRepeat(CXText wSource, CXText wText);   // ------------------------->>> 文本_是否重复 <<<-------------------------

//@别名   十六到十()
INT64 Hex2Dec(CXText 参_十六进制文本);  // -------------------------👉 十六到十 👈 -------------------------

//@备注   返回所指定变整数所对应的十六进制文本
//@参数   所欲转换的长整数
//@参数   默认为假:去0  真:不去0
//@别名   十到十六()
CXText Dec2Hex(INT64 所欲转换的长整数, BOOL 参_是否不去零 = FALSE);  // -------------------------👉 十到十六 👈 -------------------------

//@备注   比如：欲取全文本为<12345>,现在要取出“3”，<3>的前面为“2”，<3>的后面为“4”
//@参数   欲取全文本
//@参数   前面文本
//@参数   后面文本
//@参数   起始寻找位置
//@参数   TRUE.不区分[*默认不区分];
//@别名   文本_取中间_批量(欲取全文本,前面文本,后面文本,起始寻找位置,是否不区分大小写)
CXVector<CXText> StrMids(CXText wSourceStr, CXText wLeftStr, CXText wRightStr, DWORD iStartPos = -1, BOOL bIsCase = TRUE);   // ------------------------->>> 文本_取中间_批量<<<-------------------------

//@备注   在一大串网页源码中 只取出汉字
//@参数   要取出的源文本
//@参数   可为空，默认为FALSE。
//@别名   文本_只取汉字(欲取全文本,是否去除空格和空行)
CXText GetChineseChar(CXText wSourceStr, BOOL bIsDel = FALSE);   // ------------------------->>> 文本_只取汉字 <<<-------------------------

//@备注   在一大串网页源码中 只取字母
//@参数   要取出的源文本
//@参数   0=取大小写  1只取小写  2只取大写
//@别名   文本_只取字母(欲取全文本,大小写类型)
CXText GetIndWord(CXText wSourceStr, DWORD dwType = 0);   // ------------------------->>> 文本_只取字母 <<<-------------------------

//@备注   在一大串网页源码中 只取数字
//@参数   要取出的源文本
//@别名   文本_只取数字(欲取全文本)
CXText GetNumber(CXText wSourceStr);   // ------------------------->>> 文本_只取数字 <<<-------------------------

//@备注   是否包含中文
//@参数   要分割的源文本
//@别名   文本_是否有中文(参_欲取全文本)
BOOL IsTextIncludeChinese(CXText wSourceStr);   // ------------------------->>> 文本_是否有中文 <<<-------------------------

//@备注   是否是中文
//@参数   要分割的源文本
//@别名   文本_是否全中文(参_欲取全文本)
BOOL IsTextChinese(CXText wSourceStr);   // ------------------------->>> 文本_是否全中文 <<<-------------------------

//@备注   是否全字母
//@参数   要分割的源文本
//@别名   文本_是否全字母(参_欲取全文本)
BOOL IsTextLetters(CXText wSourceStr);   // ------------------------->>> 文本_是否全字母 <<<-------------------------

//@备注   是否全小写字母
//@参数   要分割的源文本
//@别名   文本_是否全小写字母(参_欲取全文本)
BOOL IsTextLowLetters(CXText wSourceStr);   // ------------------------->>> 文本_是否全小写字母 <<<-------------------------

//@备注   文本_是否全大写字母
//@参数   要分割的源文本
//@别名   文本_是否全大写字母(参_欲取全文本)
BOOL IsTextCapChinese(CXText wSourceStr);   // ------------------------->>> 文本_是否全大写字母 <<<-------------------------

//@备注   在一大串网页源码中 只取符号
//@参数   要取出的源文本
//@别名   文本_只取符号(欲取全文本)
CXText GetCharacter(CXText wSourceStr);   // ------------------------->>> 文本_只取符号 <<<-------------------------

//@分组} XM_文本操作
//=========================👆 👆 👆 👆 XM_文本操作 👆 👆 👆 👆====================================







//=========================👇 👇 👇 👇 XM_文件目录 👇 👇 👇 👇====================================
//@分组{ XM_文件目录

//@备注   检测最后一个字符是否为"\"如果不是则加上，某些支持库或组件要求必须结尾有\等符号才能识别为目录
//@参数   传入要检测和处理的目录路径
//@别名   目录_处理(要处理的目录)
CXText XM_Files_DirHandle(CXText dirName);

//@备注   创建多级目录
//@返回   成功返回TRUE，失败返回FALSE。if指定目录存在也会返回TRUE，不覆盖目录内容
//@参数   参_目录路径
//@别名   目录_创建(参_目录路径)
BOOL CreateDir(CXText fileDir);   // ------------------------->>> 目录_创建 <<<-------------------------

//@备注   删除指定目录下的所有文件和子目录
//@返回   如果失败,一般情况是因为删除文件失败导致的
//@参数   参_目录路径
//@别名   目录_删除(参_目录路径)
BOOL DelDir(CXText fileDir);   // ------------------------->>> 目录_删除 <<<-------------------------

//@备注   判断此目录是否存在
//@返回   TRUE表示存在,FALSE表示不存在
//@参数   参_目录路径
//@别名   目录_是否存在(参_目录路径)
BOOL DirIsExist(CXText fileDir);   // ------------------------->>> 目录_是否存在 <<<-------------------------

//@备注   取一个文件夹下面的子目录数量
//@返回   失败返回-1
//@参数   参_目录路径
//@别名   目录_取子目录数(参_目录路径)
vint GetDirSubNum(CXText parentPath);   // ------------------------->>> 目录_取子目录数 <<<-------------------------

//@备注   取出文件夹创建时间
//@返回   返回创建的时间
//@参数   参_目录路径
//@别名   目录_取创建时间(参_目录路径)
CXText GetDirCreatedDate(CXText parentPath);  // ------------------------->>> 目录_取创建时间 <<<-------------------------

//@备注   取出文件夹最后访问时间
//@返回   返回最后访问的时间
//@参数   参_目录路径
//@别名   目录_取访问时间(参_目录路径)
CXText GetDirLastAccesDate(CXText parentPath);  // ------------------------->>> 目录_取访问时间 <<<-------------------------

//@参数   参_目录路径
//@别名   目录_取短路径(参_目录路径)
CXText GetDirShortPath(CXText parentPath);  // ------------------------->>> 目录_取短路径 <<<-------------------------

//@参数   参_目录路径
//@别名   目录_取目录名(参_目录路径)
CXText GetDirShortName(CXText parentPath);  // ------------------------->>> 目录_取目录名 <<<-------------------------

//@备注   判断目录是否为空
//@返回   如果为空返回真
//@参数   参_目录路径
//@别名   目录_是否为空(参_目录路径)
BOOL IsEmptyDir(CXText parentPath);   // ------------------------->>> 目录_是否为空 <<<-------------------------

//@参数   参_目录路径
//@别名   目录_是否有子目录(参_目录路径)
BOOL IsHaveSubDir(CXText parentPath);   // ------------------------->>> 目录_是否有子目录 <<<-------------------------

//@备注   取出Temp目录,如:C:\\DOCUME~1\\ADMINI~1\\LOCALS~1\\Temp
//@别名   目录_取临时目录()
CXText GetTempDir();   // ------------------------->>> 目录_取临时目录 <<<-------------------------

//@备注   C:\WINDOWS\system32
//@别名   目录_取system32目录()
CXText GetSystem32Dir();   // ------------------------->>> 目录_取system32目录 <<<-------------------------

//@备注   C:\\WINDOWS\\system32
//@别名   目录_取SysWOW64目录()
CXText GetSysWOW64Dir();   // ------------------------->>> 目录_取SysWOW64目录 <<<-------------------------

//@备注   返回指定文件或目录的上一级目录路径
//@参数   如：C:\\001\\002\\0.txt则返回C:\\001\\002\\；
//@别名   目录_取父路径()
CXText GetParentDir(CXText 参_文件或目录);   // ------------------------->>> 目录_取父路径 <<<-------------------------

//@参数   1 AppDat局_项名数据
//2 IE临时目录
//3 局_项数组DBurning
//4 局_项数组ookies
//5 桌面
//6 收藏夹
//7 字体
//8 历史记录
//9 Lo局_项数组alAppDat局_项名数据
//10 Lo局_项数组alSettings
//11 我的音乐
//12 我的图片
//13 我的视频
//14 NetHood
//15 我的文档
//16 PrintHood
//17 开始_程序
//18 我最近的文档
//19 发送到
//20 开始菜单
//21 启动文件夹
//22 Templates
//23 所有用户_管理工具
//24 所有用户_AppDat局_项名数据
//25 所有用户_桌面
//26 所有用户_文档
//27 所有用户_收藏夹
//28 所有用户_开始_程序
//29 所有用户_开始菜单
//30 所有用户_启动文件夹
//31 所有用户_Templates
//32 所有用户_音乐
//33 所有用户_图片
//34 所有用户_视频
//35 临时目录
//36 安装目录
//37 系统目录
//38 用户目录
//39 所有用户
//40 程序文件
//41 所有用户_程序文件
//42 系统盘
//43 软件安装目录
//@别名   目录_取特定目录Ex(参_目录类型)
CXText GetSpecificDirEx(DWORD 参_目录类型 = 1);   // ------------------------->>> 目录_取特定目录Ex <<<-------------------------

//@备注   根据文件路径 取出文件名
//@返回   成功返回文件名
//@参数   文件路径
//@参数   真.带后缀  假.不带[*默认]
//@别名   文件_取文件名(参_文件路径)
CXText GetFileName(CXText 参_文件路径, BOOL 参_是否带后缀 = FALSE);   // -------------------------👉 文件_取文件名 👈 -------------------------

//@备注   根据文件路径 取出文件名
//@返回   成功返回文件名
//@参数   参_文件路径
//@参数   TRUE.带后缀
//@别名   文件_取文件名2(参_文件路径,参_是否带后缀)
CXText GetFileName2(CXText 参_文件路径, BOOL 参_是否带后缀 = FALSE);   // ------------------------->>> 文件_取文件名2 <<<-------------------------

//@备注   复制文件
//@返回   成功返回TRUE,失败返回FALSE
//@参数   源文件
//@参数   目标文件
//@参数   默认覆盖
//@别名   文件_复制(参_被复制文件名,参_复制到文件名,参_是否覆盖)
BOOL CopyFile_(CXText 参_被复制文件名, CXText 参_复制到文件名, BOOL 参_是否覆盖 = TRUE);   // ------------------------->>> 文件_复制 <<<-------------------------

//@备注   返回一个文件的后缀名
//@返回   如：.jpg  如果没有后缀,返回空
//@参数   带后缀文件名
//@别名   文件_取扩展名(参_文件名)
CXText GetFileExtName(CXText name);  // -------------------------👉 文件_取扩展名 👈 -------------------------

//@备注   打开文件返回文件句柄
//@返回   失败返回-1,成功返回文件句柄
//@参数   要打开的完整的文件路径
//@参数   0.无限制 1.读入 2.写出 3.执行 4.读写
//@参数   0、允许其它进程任意读写此文件；1、允许其它进程读此文件；2、允许其它进程写此文件；3、允许其它进程读写此文件；4、允许其他进程删除文件；
//@别名   文件_打开(参_文件名,参_打开方式,参_共享方式)
vint OpenFile_(CXText 参_文件名, DWORD 参_打开方式 = 0, DWORD 参_共享方式 = 3);   // ------------------------->>> 文件_打开 <<<-------------------------

//@参数   参_文件句柄
//@别名   文件_关闭(参_文件句柄)
BOOL CloseFile_(vint 参_文件句柄);   // ------------------------->>> 文件_关闭 <<<-------------------------

//@备注   设置当前读写位置
//@返回   成功返回TRUE,失败返回FALSE
//@参数   参_文件句柄
//@参数   参_移动距离
//@别名   文件_移动读写位置(参_文件句柄,参_移动距离)
BOOL SetFileSeek(vint 参_文件句柄, vint 参_移动距离);   // ------------------------->>> 文件_移动读写位置 <<<-------------------------

//@备注   设置当前读写位置
//@返回   成功返回TRUE,失败返回FALSE
//@参数   参_文件句柄
//@别名   文件_取读写位置(参_文件句柄)
vint GetFileSeek(vint 参_文件句柄);   // ------------------------->>> 文件_取读写位置 <<<-------------------------

//@备注   设置当前读写位置到文件头部
//@返回   成功返回TRUE,失败返回FALSE
//@参数   参_文件句柄
//@别名   文件_到文件首(参_文件句柄)
BOOL SetFileSeekToBeign(vint 参_文件句柄);   // ------------------------->>> 文件_到文件首 <<<-------------------------

//@备注   设置当前读写位置到文件尾部
//@返回   成功返回TRUE,失败返回FALSE
//@参数   参_文件句柄
//@别名   文件_到文件尾(参_文件句柄)
BOOL SetFileSeekToEnd(vint 参_文件句柄);   // ------------------------->>> 文件_到文件尾 <<<-------------------------

//@备注   写出字节集数据,自动移动读写位置
//@参数   参_文件句柄
//@参数   参_要写出的数据
//@别名   文件_写出字节集(参_文件句柄,参_要写出的数据)
BOOL WriteBin(vint 参_文件句柄, CXBytes 参_要写出的数据);   // ------------------------->>> 文件_写出字节集 <<<-------------------------

//@备注   写出文本数据,自动移动读写位置
//@参数   参_文件句柄
//@参数   参_要写出的数据
//@别名   文件_写出文本(参_文件句柄,参_要写出的数据)
BOOL WriteText(vint 参_文件句柄, CXText 参_要写出的数据);   // ------------------------->>> 文件_写出文本 <<<-------------------------

//@备注   将文件读入到内存,注意：为维持文件原始结构,底层为单字节,如果是文本文件请使用 取文本指针A()
//@返回   返回字节集接收尺寸(文件尺寸)
//@别名   文件_读入文件(文件名,返回字节集)
int XM_Files_ReadFile(CXText fileName, CXBytes& fileByte);

//@备注   读取字节集数据
//@返回   成功返回读取长度,失败返回0
//@参数   参_文件句柄
//@参数   参_要读取的数据
//@参数   默认读取全部 文件_取大小
//@别名   文件_读入字节集(参_文件句柄,参_要读取的数据,参_读入长度)
vint ReadBin(vint 参_文件句柄, CXBytes 参_要读取的数据, vint 参_读入长度 = -1);   // ------------------------->>> 文件_读入字节集 <<<-------------------------

//@参数   参_文件句柄
//@参数   默认读取全部 文件_取大小
//@别名   文件_读入文本(参_文件句柄,参_读入长度)
CXText ReadText(vint 参_文件句柄, vint 参_读入长度 = -1);   // ------------------------->>> 文件_读入文本 <<<-------------------------

//@备注   取文件大小
//@参数   参_文件句柄
//@别名   文件_取尺寸(参_文件句柄)
vint GetFileLen(vint 参_文件句柄);   // ------------------------->>> 文件_取尺寸 <<<-------------------------

//@备注   判断一个指定的文件路径是否为目录
//@返回   是目录返回TRUE, 不是目录或文件路径不存在返回FALSE
//@参数   参_文件路径
//@别名   文件_是否为目录(参_文件路径)
BOOL IsDir(CXText filePath);   // ------------------------->>> 文件_是否为目录 <<<-------------------------

//@参数   参_文件路径
//@别名   文件_取目录(参_文件路径)
CXText GetFileDir(CXText filePath);   // ------------------------->>> 文件_取目录 <<<-------------------------

//@参数   参_文件路径
//@别名   文件_是否存在(参_文件路径)
BOOL IsFileExist(CXText filePath);   // ------------------------->>> 文件_是否存在 <<<-------------------------

//@备注   返回一个文件或目录的属性
//@返回   1、只读文件； 2、隐藏文件；  4、系统文件； 16、子目录；32、存档文件
//要判断是否设置了某个属性，在返回值与想要得知的属性值之间使用“位与”命令进行比较。
//if所得的结果不为零，则表示设置了这个属性值。if取文件属性失败，将返回 -1
//@参数   参_文件路径
//@别名   文件_取属性(参_文件路径)
DWORD GetFileAttr(CXText filePath);   // ------------------------->>> 文件_取属性 <<<-------------------------

//@参数   参_文件路径
//@参数   1、只读文件； 2、隐藏文件；  4、系统文件； 16、子目录；32、存档文件
//通过相加常量值可以设置多个属性
//@别名   文件_置属性(参_文件路径,参_属性值)
BOOL SetFileAttr(CXText filePath, DWORD fileAttr);   // ------------------------->>> 文件_置属性 <<<-------------------------

//@参数   参_文件路径
//@参数   1、只读文件； 2、隐藏文件；  4、系统文件； 16、子目录；32、存档文件
//通过相加常量值可以设置多个属性
//@别名   文件_移除属性(参_文件路径,参_属性值)
BOOL DelFileAttr(CXText filePath, DWORD fileAttr);   // ------------------------->>> 文件_移除属性 <<<-------------------------

//@备注   通过文件路径取出文件大小
//@参数   参_文件路径
//@别名   文件_取大小(参_文件路径)
INT64 GetFileSize(CXText filePath);   // ------------------------->>> 文件_取大小 <<<-------------------------

//@参数   参_文件路径
//@别名   文件_删除(参_文件路径)
BOOL DelFile(CXText filePath);   // ------------------------->>> 文件_删除 <<<-------------------------

//@备注   可以删除掉所有类型的文件包括运行的程序
//@参数   文件所在位置
//@别名   文件_强制删除(参_文件路径)
BOOL DelFileForced(CXText filePath);   // ------------------------->>> 文件_强制删除 <<<-------------------------

//@备注   移动文件
//@参数   参_原文件路径
//@参数   参_目标文件路径
//@别名   文件_移动(参_原文件路径,参_目标文件路径)
BOOL MoveFile_(CXText oldFilePath, CXText newFilePath);   // ------------------------->>> 文件_移动 <<<-------------------------

//@返回   成功返回文件数组,失败返回空数组
//@参数   参_目录
//@参数   可以使用多字符 (*) 和单字符 (?) 通配符来指定多重文件
//@参数   用来同步接受回调结果  void 文件枚举_回调(文本型 参_目录,文本型 参_文件名)
//@参数   这个参数不需要填,内部使用了静态变量,所以为了保证结果的准确性增加一个参数
//@别名   文件_枚举(参_目录,参_扩展名,参_回调指针,参_是否清空)
CXVector<CXText> ListFile(CXText fileDir, CXText 参_扩展名 = L"*.*", vint 参_回调指针 = 0, BOOL 参_是否清空 = TRUE);   // ------------------------->>> 文件_枚举 <<<-------------------------

//@备注   取文件的版本号
//@参数   参_文件路径
//@别名   文件_取版本(参_文件路径)
CXText GetFileVersion(CXText fileName);   // ------------------------->>> 文件_取版本 <<<-------------------------

//@备注   返回短文件名
//@参数   参_文件路径
//@别名   文件_到短文件名(参_文件路径)
CXText GetShortFileName(CXText fileName);   // ------------------------->>> 文件_到短文件名 <<<-------------------------

//@备注   返回长文件名
//@参数   参_文件路径
//@别名   文件_到长文件名(参_文件路径)
CXText GetLongFileName(CXText fileName);   // ------------------------->>> 文件_到长文件名 <<<-------------------------

//@别名   文件_重启电脑后替换(旧路径,新路径,删除旧文件)
BOOL X_File_MoveFileOnReboot(CXText oldFile, CXText newFile, BOOL removeOldFile);

//@参数   判断一个可执行映像是否为64位
//@别名   文件_是否为64位()
BOOL XM_File_FileIfIsX64(CXText fileName);

//@别名   文件_是否被占用(文件名)
BOOL XM_File_FileWhetItIsLocked(CXText fileName);

//@备注   复制、移动、重命名或删除文件系统对象(需要自行初始化COM)
//@参数   命令类型            1、移动；2、复制；3、删除；4、重命名
//@参数   源文件名            操作文件名
//@参数   目标文件或目录名称   目录名称
//@参数   文件操作选项        1、不询问；2、不提示；4、不显示进度
//@别名   文件_文件操作(命令类型,源文件名,目标文件或目录名称,文件操作选项)
BOOL XM_Files_FileOperation(int CommendType, CXText fileName, CXText targetDir = L"", int fileOption = 0);

//@备注   将指定文件删除到回收站,成功返回真,失败返回假
//@参数   欲删除的文件名  欲删除的全路径文件名
//@参数   删除方式选项    1: 不询问删除;  2: 不提示错误;  4: 不显示进度。如果被省略，默认值为 0
//@别名   文件_删除到回收站(欲删除的文件名,删除方式选项)
BOOL XM_Files_FileDelToRecycle(CXText fileName, int delType = 0);

//@别名   文件_改名(原文件名,新文件名)
BOOL XM_Files_FileRename(CXText oldFile, CXText newFile);

//@备注   成功则打开文件所在目录并选中文件，失败返回假(需要自行初始化COM)
//@别名   文件_定位(欲定位的文件,编辑模式)
BOOL XM_Files_FileLocation(CXText fileName, BOOL editMode = FALSE);

//@备注   将目标目录的文件和源目录中的文件进行对比，将不同的文件同步到目标目录里
//@参数   源目录 源目录，目录不以\结尾会自动添加
//@参数   目标目录 欲更新目标的目录，目录不以\结尾会自动添加
//@别名   目录_同步更新(源目录,目标目录)
VOID XM_Files_DirSyncUpdate(CXText sourcePath, CXText targetPath);

//@备注   取一个文件夹下级子目录.成功返回子目录数量,失败返回0.
//@参数   如：D:\Program Files；目录分割符请用\，路径不以\结尾会自动添加
//@参数   用来装载返回的子目录路径
//@参数   假=不带，真=带
//@参数   默认为假；真=按字母a-z排序  假=不排序
//@别名   目录_枚举子目录(父文件夹路径,子目录数组,是否带路径,是否按字母排序)
int XM_Files_DirEnumDirList(CXText parentPath, CXVector<CXText>& retList, BOOL addPath = FALSE, BOOL enume = FALSE, BOOL isSort = FALSE);

//@别名   目录_浏览(标题,显示文件,初始目录,地址栏,新样式,父窗口句柄)
CXText XM_Files_DirBrowseForFolder(CXText title = L"请选择一个文件夹", BOOL showFiles = FALSE, CXText initialDirectory = L"", BOOL addressBar = FALSE, BOOL newStyle = FALSE, HWND phWnd = 0);

//@别名   目录_监控文件修改(要监视的目录的完整路径,监视整个目录树)
VOID XM_Files_DirMonitoringChanges(CXText changeDir, BOOL bWatchSubtree = FALSE);

//@别名   文件字节集_取MD5(字节集资源)
CXText XMCheck_GetMD5_Bytes(CXBytes& data);

//@备注   【严格】检查目录是否合规范，不和规范的目录返回假。判断标准:盘符:\目录
//@参数   需要检查的完整的目录路径，不接受相对路径
//@参数   如果设置为真，如果是盘符根目录返回假。默认为真。
//@别名   目录_是否符合规范(要检查的目录,是否禁止为根目录)
BOOL XM_File_DirIsItNormative(CXText dirName, BOOL banRootPath = TRUE);

//@返回   成功返回当前目录
//@别名   目录_取当前目录()
CXText XM_Files_GetCurrentDir();

//@参数   遍历可执行映像的PE导出表获取函数名称
//@别名   文件_遍历PE导出表(文件名,导出函数列表)
int XM_Files_ErgodicExportTables(CXText fileName, CXVector<CXText>& rExportFuncList);

//@参数   遍历可执行映像的PE导入表获取函数名称
//@别名   文件_遍历PE导入表(文件名,导出函数列表)
int XM_Files_ErgodicImportTables(CXText fileName, CXVector<CXText>& rExportFuncList);

//@备注   成功则打开文件或文件夹所在目录并选中(部分情况下需自行初始化COM)
//@别名   文件_定位多个(所在文件夹,欲定位的文件或文件夹)
BOOL XM_Files_FileLocationMultiples(CXText dirName, CXVector<CXText>fileList);

//@别名   文件_句柄取路径(文件句柄)
CXText XM_File_HendleGetPath(HANDLE hFile);

//@别名   文件_取类型(文件路径)
CXText XM_File_GetFileType(CXText fileName);

//@别名   文件_取路径盘符(文件路径)
CXText XM_File_GetPathDriveLetter(CXText fileName);

//@别名   文件_取真实尺寸(文件路径)
ULONGLONG XM_File_GetFileRealSize(CXText fileName);

//@别名   文件_取图标句柄(文件路径)
HANDLE XM_File_GetFileIconHand(CXText fileName);

//@别名   文件_去扩展名(文件路径)
BOOL XM_File_FileDelSuffix(CXText fileName);

//@别名   文件_删除某类文件(欲删除文件的目录,欲删除的文件类型,是否包含子目录)
int XM_File_DelWTypeFiles(CXText dirName, CXText Suffix, BOOL enumSon);

//@别名   文件_执行(文件路径,命令行,显示类型)
BOOL XM_File_FileExecute(CXText fileName, CXText Commend, int windType);

//@别名   文件_置时间(文件路径,日期时间)
BOOL XM_File_SetFileTime(CXText filePath, CSysDateTime Create);

//@分组} XM_文件目录
//=========================👆 👆 👆 👆 XM_文件目录 👆 👆 👆 👆====================================







//=========================👇 👇 👇 👇 XM_系统操作 👇 👇 👇 👇====================================
//@分组{ XM_数据类型

//@别名   系统_屏幕信息
struct Display_Info
{
	//@别名   色深
	DWORD dmBitsPerPel;
	//@别名   宽度
	DWORD dmPelsWidth;
	//@别名   高度
	DWORD dmPelsHeight;
	//@别名   刷新率
	DWORD dmDisplayFrequency;
};

//@分组} XM_数据类型

//=====================================================================================

//@分组{ XM_系统操作

//@备注   取出API函数的地址
//@别名   系统_取API地址(参_DLL名字,参_函数名字)
vint GetApiAddr(CXText wDllName, CXText wFuncName);

//@备注   调用函数
//@别名   程序_Call(参_子程序首地址,参数,参数可拓展)
vint CallFun_XM(vint funadd, vint Variable = 0, ...);  // -------------------------👉 程序_Call 👈 -------------------------

//@备注   调用函数,目标函数调用约定为: __cdecl
//@别名   程序_Call_cdecl(参_子程序首地址,参数,参数可拓展)
vint CallCdeclFun(vint funadd, vint Variable, ...);  // -------------------------👉 程序_Call_cdecl 👈 -------------------------

//@备注   调用函数,目标函数调用约定为: __stdcall
//@别名   程序_Call_std(参_子程序首地址,参数,参数可拓展)
vint CallStdFun(vint funadd, vint Variable, ...);  // -------------------------👉 程序_Call_std 👈 -------------------------

//@备注   调用函数,目标函数调用约定为: ___fastcall
//@别名   程序_Call_fast(参_子程序首地址,参数,参数可拓展)
vint CallFastFun(vint funadd, vint Variable, ...);  // -------------------------👉 程序_Call_fast 👈 -------------------------

//@备注   生成标准的GUID格式：D68B048B - 2349 - 11ED - 83D3 - 04421A0D7DBB
//@别名   程序_生成GUID()
CXText GenerateGuid();  // -------------------------👉 程序_生成GUID 👈 -------------------------

//@备注   生成标准的GUID格式：D68B048B - 2349 - 11ED - 83D3 - 04421A0D7DBB
//@别名   程序_生成GUID2()
CXText GenerateGuid2();  // -------------------------👉 程序_生成GUID2 👈 -------------------------

//@备注   Windows 系统启动后到现在为止所经历过的微妙数
//@返回   1毫秒=1000微妙
//@别名   取启动时间Ex()
INT64 GetTickCountEx();  // -------------------------👉 取启动时间Ex 👈 -------------------------

//@备注   Windows 系统启动后到现在为止所经历过的微妙数
//@返回   1毫秒=1000微妙
//@别名   取启动时间Ex_()
INT64 GetTickCountEx_();  // -------------------------👉 取启动时间Ex_ 👈 -------------------------

//@别名   系统_重启()
BOOL RestartPc();  // -------------------------👉 系统_重启 👈 -------------------------

//@别名   系统_强制重启()
BOOL RestartPcForced();  // -------------------------👉 系统_强制重启 👈 -------------------------

//@别名   系统_注销()
BOOL LoginOff();  // -------------------------👉 系统_注销 👈 -------------------------

//@别名   系统_强制注销()
BOOL LoginOffForced();  // -------------------------👉 系统_强制注销 👈 -------------------------

//@别名   系统_关机()
BOOL Shutdown();  // -------------------------👉 系统_关机 👈 -------------------------

//@别名   系统_强制关机()
BOOL ShutdownForced();  // -------------------------👉 系统_强制关机 👈 -------------------------

//@别名   系统_刷新屏幕()
BOOL RefreshScreen();  // -------------------------👉 系统_刷新屏幕 👈 -------------------------

//@备注   切断电源 实现快速关机
//@别名   系统_关电源()
BOOL ShutdownSystem();  // -------------------------👉 系统_关电源 👈 -------------------------

//@备注   获取当前系统的用户名
//@别名   系统_取用户名()
CXText GetUserName_();  // -------------------------👉 系统_取用户名 👈 -------------------------

//@备注   获取计算机名
//@别名   系统_取计算机名()
CXText GetPcName();  // -------------------------👉 系统_取计算机名 👈 -------------------------

//@别名   处理事件_()
void DealEvent();  // -------------------------👉 处理事件_ 👈 -------------------------

//@备注   不占用cpu，窗口不卡死，不影响其它代码执行
//@参数   延时时间 1000毫秒 = 1秒  留空为无限等待
//@参数   延时单位 默认为毫秒  0=毫秒  1=秒  2=分钟  3=小时
//@别名   程序_延时(延时时间,延时单位)
void SleepEx_XM(long time = 0, int unit = 0);  // -------------------------👉 程序_延时 👈 -------------------------

//@备注   取Cmd的路径
//@别名   程序_取cmd路径()
CXText GetCmdSpec();  // -------------------------👉 程序_取cmd路径 👈 -------------------------

//@别名   系统_取CPU型号()
CXText GetCpuModel();  // -------------------------👉 程序_取CPU型号 👈 -------------------------

//@备注   通过Nt函数获取自身PEB来获取系统版本
//@返回   0、未知； 1、Win95； 2、Win98； 3、WinME； 4、WinNT；5、Win2000； 6、WinXP； 7、Win2003； 8、Vista；9、Win7；10、Win8； 11、Win8.1； 12、Win10 13、Win11
//@别名   系统_取系统版本()
DWORD GetOsVersion();  // -------------------------👉 系统_取系统版本 👈 -------------------------

CXText  系统_读环境变量(CXText 环境变量名称);  // -------------------------👉 系统_读环境变量 👈 -------------------------

//@备注   取CPU核心数
//@别名   系统_取CPU核心数()
DWORD GetCpuNum();  // -------------------------👉 系统_取CPU核心数 👈 -------------------------

//@别名   系统_禁用DPI缩放()
BOOL DisableDPI();  // -------------------------👉 系统_禁用DPI缩放 👈 -------------------------

//@返回   成功返回缩放比
//@别名   系统_取系统DPI()
DWORD GetDPI();  // -------------------------👉 系统_取系统DPI 👈 -------------------------

//@返回   成功返回缩放比
//@别名   系统_取系统DPI_()
DWORD GetDPI2();  // -------------------------👉 系统_取系统DPI_ 👈 -------------------------

//@备注   (64位中不可用)注意:该命令会阻塞,一直到cmd中的内容执行完毕后才会返回
//@参数   欲执行的dos命令
//@参数   DOS即时回显信息回调函数  参考 回调模板_取DOS执行结果
//@别名   系统_取DOS执行结果(参_命令行文本,参_即时回显回调)
CXText GetRunDosRes(CXText wCommand, vint lpConsoleCallBak = 0);  // -------------------------👉 系统_取DOS执行结果👈 -------------------------

//@备注   (64位中不可用)返回当前系统的名字 例如 Microsoft Windows 10 专业版
//@别名   系统_取操作系统名称()
CXText GetOsName();  // -------------------------👉 系统_取操作系统名称 👈 -------------------------

//@备注   取任务栏高度
//@别名   系统_取任务栏高度()
DWORD GetTaskbarHight();  // -------------------------👉 系统_取任务栏高度 👈 -------------------------

//@别名   系统_任务栏隐藏()
BOOL HideTaskbar();  // -------------------------👉 系统_任务栏隐藏 👈 -------------------------

//@别名   系统_任务栏显示()
BOOL ShowTaskbar();  // -------------------------👉 系统_任务栏显示 👈 -------------------------

//@别名   系统_取屏幕分辨率()
Display_Info GetDisplaySize();  // -------------------------👉 系统_取屏幕分辨率 👈 -------------------------

//@备注   设置屏幕分辨率
//@返回   返回值说明:0设置成功;1重启后生效;-2不支持的分辨率;-1驱动无效或不支持
//@参数   屏幕信息
//@参数   1:临时,退出软件或重启后恢复原来的配置; 2:全局, 设置后将一直使用新分辨率.
//@别名   系统_置屏幕分辨率(参_屏幕信息,参_设置模式)
DWORD SetDisplaySize(Display_Info dInfo, DWORD iType = 2);  // -------------------------👉 系统_置屏幕分辨率 👈 -------------------------

//@备注   内存中加载EXE, 翻译自精易模块
//@参数   欲执行的程序，不支持某些加了壳的程序，请自行测试
//@参数   为程序提供的命令行参数，不需要请留空。
//@参数   外壳程序的路径(如果用系统程序做外壳，如cmd.exe、svchost.exe，可以实现穿防火墙，呵呵)，不支持某些程序，请自行测试；不在当前目录下要提供绝对路径；留空默认为cmd.exe，如果无法运行，请换用不同的程序尝试。
//@参数   默认为假，即不等待
//@参数   1#隐藏窗口； 2#普通激活； 3#最小化激活； 4#最大化激活； 5#普通不激活； 6#最小化不激活。如果省略本参数，默认为“普通激活”方式。
//@参数   用来接收在内存中执行的exe的运行信息(进程、主线程的句柄和ID)。不需要可留空。当不使用时需要关闭进程和线程句柄
//@返回   成功返回真, 失败返回假
//@别名   程序_内存中加载exe()
BOOL RunEXEformMem(const CXBytes& 欲执行的程序, const wchar_t* 命令行 = 0, const wchar_t* 外壳程序路径 = 0,
	BOOL 等待程序运行完毕 = FALSE, int 窗口显示方式 = 0, __out PROCESS_INFORMATION* 进程信息 = 0);

//@备注 内存中加载EXE, 来源于CSDN
//@参数 欲执行的程序，不支持某些加了壳的程序，请自行测试
//@参数 为程序提供的命令行参数，不需要请留空。
//@参数 外壳程序的路径(如果用系统程序做外壳，如cmd.exe、svchost.exe，可以实现穿防火墙，呵呵)，不支持某些程序，请自行测试；不在当前目录下要提供绝对路径；留空默认为cmd.exe，如果无法运行，请换用不同的程序尝试。
//@参数 默认为假，即不等待
//@参数 ShowWindow() API 对应参数, 例如: SW_SHOW, SW_HIDE
//@参数 用来接收在内存中执行的exe的运行信息(进程、主线程的句柄和ID)。不需要可留空。当不使用时需要关闭进程和线程句柄
//@别名 程序_内存中运行EXE2(欲执行的程序, 命令行, 外壳程序路径, 等待程序运行完毕, 窗口显示方式, 进程信息)
//@返回 成功返回真, 失败返回假
//@别名   程序_内存中加载exe2()
BOOL MemExecute(const CXBytes& data_, const wchar_t* pCmdLine, const wchar_t* pShellProgram = 0,
	BOOL bWait = FALSE, int showWindow = 0, __out PROCESS_INFORMATION* pProcessInfo = 0);

//@备注   向系统中增加一个计划任务，该操作在WIN7上面需要管理员权限
//@参数   用于显示在系统中的计划任务的名称
//@参数   执行文件的路径,可以EXE也可以BAT
//@参数   方式有以下几种:,0=一次,1=在系统启动时,2=在用户登录时,3=在系统空闲时.
//@参数   需要执行该任务的用户名.if不需要可以留空
//@参数   用户名对应的密码.if不需要可以留空.if是已解锁电脑则无需输入密码
//@参数   if执行方式是一次,则必须有该值,格式为\
//@参数   如果为真,则忽略任何错误,强制创建任务
CXText 系统_计划任务自启(CXText 计划任务名, CXText 计划任务执行文件路径, int 计划任务执行方式, CXText 执行任务的用户名 = L"", CXText 执行任务的密码 = L"", CXText 任务执行时间 = L"", BOOL 是否强制创建 = TRUE);

//@备注   在注册表中添加须自启动的应用程序信息,当“是否检查”参数为TRUE时返回值才具有意义，TRUE表明已添加为自启动，FALSE表明不是自启动
//@参数   在注册表中添加须自启动的应用程序信息,当“是否检查”参数为TRUE时返回值才具有意义，TRUE表明已添加为自启动，FALSE表明不是自启动
//@参数   欲写入注册表的项目名称
//@参数   应用程序全路径,当参数“删除”为TRUE时可空,else不能为空
//@参数   是否删除自启动项,默认为假
//@参数   检查是否已添加自启动信息,此参数为TRUE时,将不进行增删注册表的行为,仅为检查
BOOL 系统_注册表自启(CXText 标识名称, CXText 应用程序路径 = L"", BOOL 删除 = FALSE, BOOL 是否检查 = FALSE);


//@别名   XM_ShellCode加载
class XM_ShellCodeLoader
{
public:
	BOOL Function_Pointer(CXBytes shellcode);



};



//@分组} XM_系统操作
//=========================👆 👆 👆 👆 XM_系统操作 👆 👆 👆 👆====================================


//=========================👇 👇 👇 👇 XM_网络访问 👇 👇 👇 👇====================================
//@分组{ XM_网络访问

//@备注   取本机的外网IP
//@别名   取外网IP()
CXText GetWanIpByTCP();  // -------------------------👉 取外网IP 👈 -------------------------



//@分组} XM_网络访问
//=========================👆 👆 👆 👆 XM_网络访问 👆 👆 👆 👆====================================



//=========================👇 👇 👇 👇 XM_时钟操作 👇 👇 👇 👇====================================
//@分组{ XM_时钟操作
//
//@备注   SetTimer KillTimer
//@别名   类_计时器
class XM_Timer
{
public:
	//@备注   创建一个时钟
//@返回   成功返回非0整数标识符, 可以将此值传递给 时钟_销毁 来销毁计时器
//@参数   要与计时器关联的窗口的句柄
//@参数   非零计时器标识符; 如果窗口句柄无效, 则忽略该参数
//@参数   以毫秒为单位。
//@参数   周期事件
//@别名   时钟_创建(窗口句柄,时钟标识,时钟周期,周期事件)
	vint CreateTimer(vint hHwnd, vint lpTimeFlags, DWORD dwElapse, vint lpTimerFunc)
	{
		return ::SetTimer((HWND)hHwnd, lpTimeFlags, dwElapse, (TIMERPROC)lpTimerFunc);
	}

	//@备注   销毁一个时钟
	//@返回   成功返回真,失败返回假
	//@参数   要与计时器关联的窗口的句柄
	//@参数   创建时用的时钟标识
	//@别名   时钟_销毁(窗口句柄,时钟标识)
	BOOL DestTimer(vint hHwnd, vint lpTimeFlags) { return ::KillTimer((HWND)hHwnd, lpTimeFlags); }
};

//@分组} XM_时钟操作
//=========================👆 👆 👆 👆 XM_时钟操作 👆 👆 👆 👆====================================








//=========================👇 👇 👇 👇 XM_指针操作 👇 👇 👇 👇====================================
//@分组{ XM_指针操作

//@备注   返回指定基本数据类型数组变量的内存空间地址指针值.除非必要且对指针概念有透彻的了解, 不要使用本方法.
//@别名   取指针_数组(数组变量数据)
template<class T>
vint GetArrPoint(T 数组变量数据);

//@备注   取通用指针
//@别名   取指针_通用(变量数据)
template<class T>
vint GetPoint(T 变量数据);

//@备注   取文本型指针
//@别名   取指针_文本型(变量数据)
vint GetTextPoint(CXText szText);

//@备注   取多字节文本型指针
//@别名   取指针_文本型A(变量数据)
vint GetTextAPoint(CXTextA szText);

//@备注   取字节集指针
//@别名   取指针_字节集(变量数据)
vint GetBinPoint(CXBytes bBin);

//@备注   返回所指定函数的指针
//@别名   取指针_方法(函数)
vint GetFuncPoint(vint Func);

//@参数   参_要转换的文本
//@别名   取指针_LPWSTR(参_要转换的文本)
vint GetLpwstrPoint(CXText szText);

//@参数   参_指针
//@别名   删指针_LPWSTR(参_指针)
VOID DelLpwstrPoint(vint lpPoint);

//@备注   读取指针的字节值
//@别名   指针_读字节(参_指针)
BYTE Point2Byte(vint lpPoint);

//@备注   读取指针的字符
//@别名   指针_读字符(参_指针)
wchar_t Point2Char(vint lpPoint);

//@备注   读取指针的短整数值
//@别名   指针_读短整数(参_指针)
WORD Point2Short(vint lpPoint);

//@备注   读取指针的整数值
//@别名   指针_读整数(参_指针)
INT Point2Int(vint lpPoint);

//@备注   读取指针的整数值
//@别名   指针_读DWORD(参_指针)
DWORD Point2Dword(vint lpPoint);

//@备注   读取指针的变整数值
//@别名   指针_读变整数(参_指针)
vint Point2INT_P(vint lpPoint);

//@备注   读取指针的长整数值
//@别名   指针_读长整数(参_指针)
INT64 Point2Long(vint lpPoint);

//@备注   读取指针的读小数值
//@别名   指针_读小数(参_指针)
FLOAT Point2Float(vint lpPoint);

//@备注   读取指针的双精度小数值
//@别名   指针_读双精度小数(参_指针)
DOUBLE Point2DoubleFloat(vint lpPoint);

//@备注   读文本型
//@别名   指针_读文本(参_指针)
CXText Point2Text(vint lpPoint);

//@备注   读文本型
//@别名   指针_读文本A(参_指针,参_读取长度)
CXTextA Point2TextA(vint lpPoint, vint lpLen = 0);

//@备注   读字节集
//@别名   指针_读字节集(参_指针,参_读取长度)
CXBytes Point2Bin(vint lpPoint, vint lpLen = 0);

//@备注   给指定的指针写入字节型
//@别名   指针_写字节(参_指针,参_写入的数据)
VOID WiretPointByte(vint lpPoint, BYTE bData);

//@备注   给指定的指针写入字节型
//@别名   指针_写字符(参_指针,参_写入的数据)
VOID WiretPointChar(vint lpPoint, wchar_t bData);

//@备注   给指定的指针写入短整数
//@别名   指针_写短整数(参_指针,参_写入的数据)
VOID WiretPointShort(vint lpPoint, WORD bData);

//@备注   给指定的指针写入整数
//@别名   指针_写整数(参_指针,参_写入的数据)
VOID WiretPointInt(vint lpPoint, INT bData);

//@备注   给指定的指针写入整数
//@别名   指针_写DWORD(参_指针,参_写入的数据)
VOID WiretPointDword(vint lpPoint, DWORD bData);

//@备注   给指定的指针写入整数
//@别名   指针_写变整数(参_指针,参_写入的数据)
VOID WiretPointInt_p(vint lpPoint, vint bData);

//@备注   给指定的指针写入长整数
//@别名   指针_写长整数(参_指针,参_写入的数据)
VOID WiretPointLong(vint lpPoint, INT64 bData);

//@备注   给指定的指针写入小数
//@别名   指针_写小数(参_指针,参_写入的数据)
VOID WiretPointFloat(vint lpPoint, FLOAT bData);

//@备注   给指定的指针写入双精度小数
//@别名   指针_写双精度小数(参_指针,参_写入的数据)
VOID WiretPointDouble(vint lpPoint, DOUBLE bData);

//@备注   给指定的指针写入任意类型数据
//@别名   指针_写通用型(参_指针,参_写入的数据)
template<class T>
VOID WiretPoint(vint lpPoint, T bData);

//@备注   给指定的指针写入字节集
//@别名   指针_写字节集(参_指针,参_写入的数据)
VOID WiretPointBin(vint lpPoint, CXBytes bData);

//@备注   给指定的指针写入U文本
//@别名   指针_写文本(参_指针,参_写入的数据)
VOID WiretPointText(vint lpPoint, CXText szData);

//@备注   给指定的指针写入文本A
//@别名   指针_写文本A(参_指针,参_写入的数据)
VOID WiretPointTextA(vint lpPoint, CXTextA szData);

//@备注   判断一个指针是否可读
//@返回   有效返回真,否则返回假
//@别名   指针_是否可读(参_指针地址,参_判断长度)
BOOL IsPointRead(vint lpPoint, vint lpLen);

//@备注   判断一个指针是否可写
//@返回   有效返回真,否则返回假
//@别名   指针_是否可写(参_指针地址,参_判断长度)
BOOL IsPointWrite(vint lpPoint, vint lpLen);

//@备注   判断一个指针是否有效
//@返回   有效返回真,否则返回假
//@别名   指针_是否有效(参_指针地址)
BOOL IsPointValue(vint lpPoint);

//@分组} XM_指针操作

//=========================👆 👆 👆 👆 XM_指针操作 👆 👆 👆 👆====================================







//=========================👇 👇 👇 👇 XM_驱动通信 👇 👇 👇 👇====================================
//@分组{ XM_驱动通信

//@别名   XM_驱动通信
class XM_Class_Device
{
public:
	//@备注   与所指定驱动进行通信,返回是否成功.
	//@参数   控制码
	//@参数   提供输入数据
	//@参数   输出数据的缓冲区地址指针,确保内存地址有效,if驱动未验证确保地址有效性,则会蓝屏.
	//@参数   提供输出缓冲区的尺寸
	//@参数   符号名
	BOOL 驱动通信(int 控制码, CXBytes 输入数据, vint 输出缓冲区, int 输出缓冲区尺寸, CXText 符号名);

	//@备注   加载所指定的驱动,返回是否成功.
	//@参数   驱动文件路径
	//@参数   用于服务数据库标记和创建服务,if系统已经存在则会直接打开服务.
	BOOL 加载驱动(CXText 驱动文件路径, CXText 服务名);

	//@备注   卸载所指定的驱动,返回是否成功.
	//@参数   必须与调用"加载驱动"方法时所传入的服务名一致
	BOOL 卸载驱动(CXText 服务名);
};

//@分组} XM_驱动通信
//=========================👆 👆 👆 👆 XM_驱动通信 👆 👆 👆 👆====================================






















*/