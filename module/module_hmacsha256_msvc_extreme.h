#pragma once
//@模块名称 HMAC-SHA256(安全哈希模块)
//@版本 1.0
//@日期 2023-10-30
//@作者 Bestkakkoii
//@QQ 1642687802
//@依赖 module_base.h
//@模块备注
// # 提供 HMAC-SHA256 和 SHA-256 哈希计算功能。 
// > 僅头文件。
// > **Generated by AI Claude & Google Gemini2.5.**
// > **由 Claude 和 Google Gemini2.5 AI 生成。**
//@模块信息结束

#ifndef MODULE_HMACSHA256_MSVC_EXTREME_H_
//@隐藏{
#define MODULE_HMACSHA256_MSVC_EXTREME_H_
//@隐藏}

//@隐藏{
#include <string>
#include <vector>
#include <cstdint>
#include <array>
#include <stdexcept> // For std::invalid_argument
#include <cstring>   // For std::memcpy, std::memset
#include <algorithm> // For std::copy, std::fill
//@隐藏}

//@隐藏{
#if __cplusplus >= 201703L
#include <string_view>
#endif

// MSVC specific intrinsics
#include <stdlib.h> // For _rotr, _byteswap_ulong

#ifndef XC_MODULE
#include "module_base.h"
#endif // XC_MODULE
//@隐藏}

//@分组{ 全局类型定义

//@别名 加密类型
namespace CryptoTypes 
{
    //@备注 SHA256 哈希结果的字节大小 (32字节)
    //@隐藏{
    constexpr 
    //@隐藏}
    size_t kSha256HashSizeBytes = 32; //@别名 哈希字节大小_SHA256
    //@备注 SHA256 内部处理块的字节大小 (64字节)
    //@隐藏{
    constexpr 
    //@隐藏}
    size_t kSha256BlockSizeBytes = 64; //@别名 处理块字节大小_SHA256

    //@备注 HMAC 内部处理块的字节大小, 与SHA256一致 (64字节)
    //@隐藏{
    constexpr 
    //@隐藏}
    size_t kHMACBlockSizeBytes = kSha256BlockSizeBytes; //@别名 HMAC处理块字节大小
    //@备注 HMAC 输出哈希结果的字节大小, 与SHA256一致 (32字节)
    //@隐藏{
    constexpr 
    //@隐藏}
    size_t kHMACHashSizeBytes = kSha256HashSizeBytes; //@别名 HMAC哈希结果字节大小

    //@备注 SHA256 哈希结果字节数组类型 (std::array<BYTE, 32>)
    //@别名 哈希字节数组_SHA256
    typedef std::array<BYTE, kSha256HashSizeBytes> Sha256HashArray;

    //@备注 SHA256 内部处理块字节数组类型 (std::array<BYTE, 64>)
    //@别名 处理块字节数组_SHA256
    typedef std::array<BYTE, kSha256BlockSizeBytes> Sha256BlockArray;
    
    //@备注 HMAC 密钥处理后的标准字节数组类型 (std::array<BYTE, 64>)
    //@别名 HMAC处理后密钥字节数组
    typedef std::array<BYTE, kHMACBlockSizeBytes> HMACProcessedKeyArray;

    //@备注 HMAC 外部负载字节数组类型 (std::array<BYTE, 64+32=96>)
    //@别名 HMAC外部负载字节数组
    typedef std::array<BYTE, kHMACBlockSizeBytes + kHMACHashSizeBytes> HMACOuterPayloadArray;
}
//@分组} 全局类型定义


//@分组{ SHA256 核心实现
//@隐藏{
class Sha256_InternalDetails; 
//@隐藏}

//@备注 SHA256 算法实现类
class Sha256
{
public:
    //@隐藏{
    static constexpr size_t HASH_SIZE_BYTES = CryptoTypes::kSha256HashSizeBytes;
    static constexpr size_t BLOCK_SIZE_BYTES = CryptoTypes::kSha256BlockSizeBytes;
    //@隐藏}

    //@备注 计算给定字节数组的SHA256哈希值
    //@参数 --data 待哈希的数据 (字节向量)
    //@返回 SHA256哈希结果 (字节向量)
    //@示例 字节集 哈希结果 = SHA256::哈希({"h","e","l","l","o"})
    //@别名 哈希(待哈希的数据)
    static CXVector<BYTE> hash(__in const CXVector<BYTE>& data)
    {
        return internalHash(data.data(), data.size());
    }

#if __cplusplus >= 201703L
    //@备注 计算给定字符串视图的SHA256哈希值 (C++17及以上)
    //@参数 --dataSv 待哈希的数据 (字符串视图)
    //@返回 SHA256哈希结果 (字节向量)
    //@示例 字节集 哈希结果 = SHA256::哈希("hello world")
    //@别名 哈希(待哈希的数据视图)
    static CXVector<BYTE> hash(__in std::string_view dataSv)
    {
        return internalHash(reinterpret_cast<const BYTE*>(dataSv.data()), dataSv.length());
    }
#endif

    //@备注 计算给定原始字节指针和长度的SHA256哈希值
    //@参数 --dataPtr 指向待哈希数据的指针
    //@参数 --dataLen 数据长度 (字节)
    //@返回 SHA256哈希结果 (字节向量)
    //@示例 字节集 哈希结果 = SHA256::哈希({"h","e","l","l","o"}, 5)
    //@别名 哈希(待哈希的原始数据)
    static CXVector<BYTE> hash(__in const BYTE* dataPtr, __in size_t dataLen)
    {
        return internalHash(dataPtr, dataLen);
    }

private:
    //@隐藏{ 
    friend class Sha256_InternalDetails; 

    static constexpr std::array<UINT, 8> INITIAL_HASH_VALUES = 
    {
        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
        0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
    };

    static constexpr std::array<UINT, 64> ROUND_CONSTANTS_VALUES = 
    {
        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
    };

    static __forceinline UINT internalRotr(UINT x, unsigned int n)
    {
        return _rotr(x, n);
    }

    static __forceinline UINT internalCh(UINT x, UINT y, UINT z)
    {
        return (x & y) ^ (~x & z);
    }

    static __forceinline UINT internalMaj(UINT x, UINT y, UINT z)
    {
        return (x & y) ^ (x & z) ^ (y & z);
    }

    static __forceinline UINT internalSigma0Upper(UINT x)
    {
        return internalRotr(x, 2) ^ internalRotr(x, 13) ^ internalRotr(x, 22);
    }

    static __forceinline UINT internalSigma1Upper(UINT x)
    {
        return internalRotr(x, 6) ^ internalRotr(x, 11) ^ internalRotr(x, 25);
    }

    static __forceinline UINT internalSigma0Lower(UINT x)
    {
        return internalRotr(x, 7) ^ internalRotr(x, 18) ^ (x >> 3);
    }

    static __forceinline UINT internalSigma1Lower(UINT x)
    {
        return internalRotr(x, 17) ^ internalRotr(x, 19) ^ (x >> 10);
    }

    static __forceinline void internalUint32ToBigEndianBytes(UINT val, BYTE* bytes)
    {
        UINT beVal = _byteswap_ulong(val);
        std::memcpy(bytes, &beVal, sizeof(UINT));
    }

    static __forceinline UINT internalBigEndianBytesToUint32(const BYTE* bytes)
    {
        UINT val;
        std::memcpy(&val, bytes, sizeof(UINT));
        return _byteswap_ulong(val);
    }

    static __fastcall void internalProcessBlock(UINT hState[8], const BYTE block[CryptoTypes::kSha256BlockSizeBytes]) 
    {
        std::array<UINT, 64> wSchedule; 

        for (int t = 0; t < 16; ++t)
        {
            wSchedule[t] = internalBigEndianBytesToUint32(&block[t * 4]);
        }
        for (int t = 16; t < 64; ++t)
        {
            wSchedule[t] = internalSigma1Lower(wSchedule[t - 2]) + wSchedule[t - 7] + internalSigma0Lower(wSchedule[t - 15]) + wSchedule[t - 16];
        }

        UINT a = hState[0];
        UINT b = hState[1];
        UINT c = hState[2];
        UINT d = hState[3];
        UINT e = hState[4];
        UINT f = hState[5];
        UINT g = hState[6];
        UINT h = hState[7];

        for (int t = 0; t < 64; t += 4)
        {
            UINT S1t0 = internalSigma1Upper(e);
            UINT chT0 = internalCh(e, f, g);
            UINT temp1T0 = h + S1t0 + chT0 + ROUND_CONSTANTS_VALUES[t] + wSchedule[t];
            UINT S0t0 = internalSigma0Upper(a);
            UINT majT0 = internalMaj(a, b, c);
            UINT temp2T0 = S0t0 + majT0;
            h = g; g = f; f = e; e = d + temp1T0; d = c; c = b; b = a; a = temp1T0 + temp2T0;

            UINT S1t1 = internalSigma1Upper(e);
            UINT chT1 = internalCh(e, f, g);
            UINT temp1T1 = h + S1t1 + chT1 + ROUND_CONSTANTS_VALUES[t+1] + wSchedule[t+1];
            UINT S0t1 = internalSigma0Upper(a);
            UINT majT1 = internalMaj(a, b, c);
            UINT temp2T1 = S0t1 + majT1;
            h = g; g = f; f = e; e = d + temp1T1; d = c; c = b; b = a; a = temp1T1 + temp2T1;

            UINT S1t2 = internalSigma1Upper(e);
            UINT chT2 = internalCh(e, f, g);
            UINT temp1T2 = h + S1t2 + chT2 + ROUND_CONSTANTS_VALUES[t+2] + wSchedule[t+2];
            UINT S0t2 = internalSigma0Upper(a);
            UINT majT2 = internalMaj(a, b, c);
            UINT temp2T2 = S0t2 + majT2;
            h = g; g = f; f = e; e = d + temp1T2; d = c; c = b; b = a; a = temp1T2 + temp2T2;

            UINT S1t3 = internalSigma1Upper(e);
            UINT chT3 = internalCh(e, f, g);
            UINT temp1T3 = h + S1t3 + chT3 + ROUND_CONSTANTS_VALUES[t+3] + wSchedule[t+3];
            UINT S0t3 = internalSigma0Upper(a);
            UINT majT3 = internalMaj(a, b, c);
            UINT temp2T3 = S0t3 + majT3;
            h = g; g = f; f = e; e = d + temp1T3; d = c; c = b; b = a; a = temp1T3 + temp2T3;
        }

        hState[0] += a;
        hState[1] += b;
        hState[2] += c;
        hState[3] += d;
        hState[4] += e;
        hState[5] += f;
        hState[6] += g;
        hState[7] += h;
    }

    static CXVector<BYTE> internalHash(const BYTE* dataPtr, size_t dataLen)
    {
        UINT hVar[8]; 
        std::memcpy(hVar, INITIAL_HASH_VALUES.data(), INITIAL_HASH_VALUES.size() * sizeof(UINT));

        CXVector<BYTE> paddedMessageVec; 
        size_t currentCapVal = ((dataLen + 1 + 8 + CryptoTypes::kSha256BlockSizeBytes - 1) / CryptoTypes::kSha256BlockSizeBytes) * CryptoTypes::kSha256BlockSizeBytes;
         if (currentCapVal < dataLen + 1 + 8 ) 
         {
            currentCapVal += CryptoTypes::kSha256BlockSizeBytes;
         }
        paddedMessageVec.reserve(currentCapVal);

        paddedMessageVec.assign(dataPtr, dataPtr + dataLen);
        paddedMessageVec.add(0x80); 

        size_t currentLenBytesVal = paddedMessageVec.size();
        size_t numZerosVal;
        if ((currentLenBytesVal % CryptoTypes::kSha256BlockSizeBytes) > (CryptoTypes::kSha256BlockSizeBytes - 8) ) 
        { 
            numZerosVal = (CryptoTypes::kSha256BlockSizeBytes - (currentLenBytesVal % CryptoTypes::kSha256BlockSizeBytes)) + (CryptoTypes::kSha256BlockSizeBytes - 8);
        } 
        else 
        {
            numZerosVal = (CryptoTypes::kSha256BlockSizeBytes - 8) - (currentLenBytesVal % CryptoTypes::kSha256BlockSizeBytes);
        }
        paddedMessageVec.resize(currentLenBytesVal + numZerosVal, 0x00);
        
        uint64_t bitLengthVal = static_cast<uint64_t>(dataLen) * 8;
        for (int i = 7; i >= 0; --i) 
        {
            paddedMessageVec.add(static_cast<BYTE>(bitLengthVal >> (i * 8)));
        }

        const BYTE* msgBlockPtrVal = paddedMessageVec.data();
        size_t numBlocksVal = paddedMessageVec.size() / CryptoTypes::kSha256BlockSizeBytes;
        for (size_t i = 0; i < numBlocksVal; ++i) 
        {
            internalProcessBlock(hVar, msgBlockPtrVal);
            msgBlockPtrVal += CryptoTypes::kSha256BlockSizeBytes;
        }

        CXVector<BYTE> resultHashVec(CryptoTypes::kSha256HashSizeBytes);
        for (int i = 0; i < 8; ++i) 
        {
            internalUint32ToBigEndianBytes(hVar[i], &resultHashVec[i * 4]);
        }
        return resultHashVec;
    }
    //@隐藏}
};
//@分组} SHA256 核心实现


//@分组{ HMAC-SHA256 核心实现
//@隐藏{
class HMACSha256_InternalDetails; 
//@隐藏}

//@备注 HMAC-SHA256 算法实现类, 所有方法均为静态, 无需实例化此类
class HMACSHA256
{
public:
    //@隐藏{
    static constexpr size_t HMAC_BLOCK_SIZE_BYTES = CryptoTypes::kHMACBlockSizeBytes;
    static constexpr size_t HMAC_HASH_SIZE_BYTES = CryptoTypes::kHMACHashSizeBytes;
    //@隐藏}
    
    //@备注 计算给定密钥和消息的HMAC-SHA256哈希值
    //@参数 --key 密钥数据 (字节向量)
    //@参数 --message 待哈希的消息数据 (字节向量)
    //@返回 HMAC-SHA256哈希结果 (字节向量)
    //@示例 字节集 哈希结果 = HMACSHA256::哈希({"s","e","c"}, {"h","e","l","l","o"})
    //@别名 哈希(密钥, 消息)
    static CXVector<BYTE> compute(__in const CXVector<BYTE>& key, __in const CXVector<BYTE>& message)
    {
        return internalCompute(key.data(), key.size(), message.data(), message.size());
    }

#if __cplusplus >= 201703L
    //@备注 计算给定密钥和消息的HMAC-SHA256哈希值 (C++17及以上, 使用字符串视图)
    //@参数 --key 密钥数据 (字符串视图)
    //@参数 --message 待哈希的消息数据 (字符串视图)
    //@返回 HMAC-SHA256哈希结果 (字节向量)
    //@别名 哈希(密钥视图, 消息视图)
    static CXVector<BYTE> compute(__in std::string_view key, __in std::string_view message)
    {
        return internalCompute(reinterpret_cast<const BYTE*>(key.data()), key.length(),
                               reinterpret_cast<const BYTE*>(message.data()), message.length());
    }
#endif

    //@备注 计算给定密钥和消息的HMAC-SHA256哈希值 (原始指针版本)
    //@参数 --keyPtr 指向密钥数据的指针
    //@参数 --keyLen 密钥数据长度 (字节)
    //@参数 --msgPtr 指向消息数据的指针
    //@参数 --msgLen 消息数据长度 (字节)
    //@返回 HMAC-SHA256哈希结果 (字节向量)
    //@示例 字节集 哈希结果 = HMACSHA256::计算哈希值({"s","e","c"}, 3, {"h","e","l","l","o"}, 5)
    //@别名 哈希(密钥指针, 密钥长度, 消息指针, 消息长度)
    static CXVector<BYTE> compute(__in const BYTE* keyPtr, __in size_t keyLen,
                __in const BYTE* msgPtr, __in size_t msgLen)
    {
        return internalCompute(keyPtr, keyLen, msgPtr, msgLen);
    }

    //@备注 计算HMAC-SHA256哈希值并返回十六进制字符串表示
    //@参数 --key 密钥数据 (字节向量)
    //@参数 --message 待哈希的消息数据 (字节向量)
    //@返回 HMAC-SHA256哈希结果的十六进制字符串
    //@示例 文本型A 哈希文本 = HMACSHA256::哈希十六进制({"s","e","c"}, {"h","e","l","l","o"})
    //@别名 哈希十六进制(密钥, 消息)
    static CXTextA computeHex(__in const CXVector<BYTE>& key, __in const CXVector<BYTE>& message)
    {
        CXVector<BYTE> hashBytesVec = internalCompute(key.data(), key.size(), message.data(), message.size());
        return internalBytesToHexString(hashBytesVec.data(), hashBytesVec.size());
    }
    
    //@备注 计算HMAC-SHA256哈希值并返回十六进制字符串表示 (字符串输入)
    //@参数 --key 密钥数据 (文本字符串)
    //@参数 --message 待哈希的消息数据 (文本字符串)
    //@返回 HMAC-SHA256哈希结果的十六进制字符串
    //@示例 文本型A 哈希文本 = HMACSHA256::哈希("secret", "hello world")
    //@别名 哈希(密钥文本, 消息文本)
    static CXTextA compute(__in const std::string& key, __in const std::string& message)
    {
        CXVector<BYTE> hashBytesVec = internalCompute(
            reinterpret_cast<const BYTE*>(key.data()), key.length(),
            reinterpret_cast<const BYTE*>(message.data()), message.length()
        );
        return internalBytesToHexString(hashBytesVec.data(), hashBytesVec.size());
    }

#if __cplusplus >= 201703L
    //@备注 计算HMAC-SHA256哈希值并返回十六进制字符串表示 (C++17及以上, 使用字符串视图)
    //@参数 --key 密钥数据 (字符串视图)
    //@参数 --message 待哈希的消息数据 (字符串视图)
    //@返回 HMAC-SHA256哈希结果的十六进制字符串
    //@别名 哈希(密钥视图, 消息视图)
    static CXTextA compute(__in std::string_view key, __in std::string_view message)
    {
        CXVector<BYTE> hashBytesVec = internalCompute(
            reinterpret_cast<const BYTE*>(key.data()), key.length(),
            reinterpret_cast<const BYTE*>(message.data()), message.length()
        );
        return internalBytesToHexString(hashBytesVec.data(), hashBytesVec.size());
    }
#endif

//@隐藏{ 
private:
    friend class HMACSha256_InternalDetails; 

    static constexpr BYTE IPAD_BYTE_CONST = 0x36;
    static constexpr BYTE OPAD_BYTE_CONST = 0x5C;

    static CryptoTypes::HMACProcessedKeyArray internalPrepareKey(const BYTE* keyPtr, size_t keyLen)
    {
        CryptoTypes::HMACProcessedKeyArray processedKeyArr{}; 

        if (keyLen > CryptoTypes::kHMACBlockSizeBytes)
        {
            CXVector<BYTE> hashedKeyVec = Sha256::hash(keyPtr, keyLen); 
            std::copy(hashedKeyVec.begin(), hashedKeyVec.end(), processedKeyArr.begin());
        }
        else
        {
            std::copy(keyPtr, keyPtr + keyLen, processedKeyArr.begin());
        }
        return processedKeyArr;
    }

    static std::string internalBytesToHexString(const BYTE* dataPtr, size_t dataLen)
    {
        if (dataPtr == nullptr || dataLen == 0)
        {
            return "";
        }

        static constexpr char hexMapCharsArr[] = "0123456789abcdef"; 
        std::string hexStrVal; 
        hexStrVal.reserve(dataLen * 2);
        for (size_t i = 0; i < dataLen; ++i)
        {
            hexStrVal.add(hexMapCharsArr[dataPtr[i] >> 4]);
            hexStrVal.add(hexMapCharsArr[dataPtr[i] & 0x0F]);
        }
        return hexStrVal;
    }

    static CXVector<BYTE> internalCompute(const BYTE* keyPtr, size_t keyLen,
                     const BYTE* msgPtr, size_t msgLen)
    {
        if (keyLen == 0)
        {
            throw std::invalid_argument("HMAC key cannot be empty.");
        }

        CryptoTypes::HMACProcessedKeyArray KPrimeArr = internalPrepareKey(keyPtr, keyLen); 
        
        CryptoTypes::HMACProcessedKeyArray kIpadArr; 
        CryptoTypes::HMACProcessedKeyArray kOpadArr; 

        for (size_t i = 0; i < CryptoTypes::kHMACBlockSizeBytes; ++i)
        {
            kIpadArr[i] = KPrimeArr[i] ^ IPAD_BYTE_CONST;
            kOpadArr[i] = KPrimeArr[i] ^ OPAD_BYTE_CONST;
        }

        CXVector<BYTE> innerPayloadVecVal; 
        innerPayloadVecVal.reserve(CryptoTypes::kHMACBlockSizeBytes + msgLen);
        innerPayloadVecVal.insert(innerPayloadVecVal.end(), kIpadArr.begin(), kIpadArr.end());
        innerPayloadVecVal.insert(innerPayloadVecVal.end(), msgPtr, msgPtr + msgLen);
        CXVector<BYTE> innerHashResultVecVal = Sha256::hash(innerPayloadVecVal.data(), innerPayloadVecVal.size()); 

        CryptoTypes::HMACOuterPayloadArray outerPayloadDataArrVal; 
        std::copy(kOpadArr.begin(), kOpadArr.end(), outerPayloadDataArrVal.begin());
        std::copy(innerHashResultVecVal.begin(), innerHashResultVecVal.end(), outerPayloadDataArrVal.begin() + CryptoTypes::kHMACBlockSizeBytes);
        
        return Sha256::hash(outerPayloadDataArrVal.data(), outerPayloadDataArrVal.size()); 
    }

public:
    HMACSHA256() = delete; 
    HMACSHA256(const HMACSHA256&) = delete;
    HMACSHA256& operator=(const HMACSHA256&) = delete;
    ~HMACSHA256() = delete;
//@隐藏}
};
//@分组} HMAC-SHA256 核心实现

#endif // MODULE_HMACSHA256_MSVC_EXTREME_H_